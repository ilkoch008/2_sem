<!DOCTYPE html>
<html class='v2' dir='ltr' xmlns='http://www.w3.org/1999/xhtml' xmlns:b='http://www.google.com/2005/gml/b' xmlns:data='http://www.google.com/2005/gml/data' xmlns:expr='http://www.google.com/2005/gml/expr'>
<head>
<link href='https://www.blogger.com/static/v1/widgets/2727757643-css_bundle_v2.css' rel='stylesheet' type='text/css'/>
<meta content='IE=EmulateIE7' http-equiv='X-UA-Compatible'/>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<meta content='blogger' name='generator'/>
<link href='https://dev.cheremin.info/favicon.ico' rel='icon' type='image/x-icon'/>
<link href='https://dev.cheremin.info/' rel='canonical'/>
<link rel="alternate" type="application/atom+xml" title="&gt;рабочие заметки - Atom" href="https://dev.cheremin.info/feeds/posts/default" />
<link rel="alternate" type="application/rss+xml" title="&gt;рабочие заметки - RSS" href="https://dev.cheremin.info/feeds/posts/default?alt=rss" />
<link rel="service.post" type="application/atom+xml" title="&gt;рабочие заметки - Atom" href="https://www.blogger.com/feeds/410416665291724878/posts/default" />
<!--[if IE]><script type="text/javascript" src="https://www.blogger.com/static/v1/jsbin/3762807459-ieretrofit.js"></script>
<![endif]-->
<meta content='https://dev.cheremin.info/' property='og:url'/>
<meta content='&gt;рабочие заметки' property='og:title'/>
<meta content='Рабочие заметки java-программиста. Производительность, concurrency, прочие извращения' property='og:description'/>
<!--[if IE]> <script> (function() { var html5 = ("abbr,article,aside,audio,canvas,datalist,details," + "figure,footer,header,hgroup,mark,menu,meter,nav,output," + "progress,section,time,video").split(','); for (var i = 0; i < html5.length; i++) { document.createElement(html5[i]); } try { document.execCommand('BackgroundImageCache', false, true); } catch(e) {} })(); </script> <![endif]-->
<title>&gt;рабочие заметки</title>
<link href="//agorbatchev.typepad.com/pub/sh/2_1_364/styles/shThemeDefault.css" rel="stylesheet" type="text/css">
<link href="//agorbatchev.typepad.com/pub/sh/2_1_364/styles/shCore.css" rel="stylesheet" type="text/css">
<script src="//agorbatchev.typepad.com/pub/sh/2_1_364/scripts/shCore.js" type="text/javascript"></script>
<script src="//agorbatchev.typepad.com/pub/sh/2_1_364/scripts/shAutoloader.js" type="text/javascript"></script>
<script src="//agorbatchev.typepad.com/pub/sh/2_1_364/scripts/shBrushJava.js" type="text/javascript"></script>
<script src="//agorbatchev.typepad.com/pub/sh/2_1_364/scripts/shBrushJScript.js" type="text/javascript"></script>
<script src="//agorbatchev.typepad.com/pub/sh/2_1_364/scripts/shBrushXml.js" type="text/javascript"></script>
<script src="//agorbatchev.typepad.com/pub/sh/2_1_364/scripts/shBrushPython.js" type="text/javascript"></script>
<style id='page-skin-1' type='text/css'><!--
/*
-----------------------------------------------
Blogger Template Style
Name:     Simple
Designer: Josh Peterson
URL:      www.noaesthetic.com
----------------------------------------------- */
/* Variable definitions
====================
<Variable name="keycolor" description="Main Color" type="color" default="#66bbdd"/>
<Group description="Page Text" selector="body">
<Variable name="body.font" description="Font" type="font"
default="normal normal 12px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="body.text.color" description="Text Color" type="color" default="#222222"/>
</Group>
<Group description="Backgrounds" selector=".body-fauxcolumns-outer">
<Variable name="body.background.color" description="Outer Background" type="color" default="#66bbdd"/>
<Variable name="content.background.color" description="Main Background" type="color" default="#ffffff"/>
<Variable name="header.background.color" description="Header Background" type="color" default="transparent"/>
</Group>
<Group description="Links" selector=".main-outer">
<Variable name="link.color" description="Link Color" type="color" default="#2288bb"/>
<Variable name="link.visited.color" description="Visited Color" type="color" default="#888888"/>
<Variable name="link.hover.color" description="Hover Color" type="color" default="#33aaff"/>
</Group>
<Group description="Blog Title" selector=".header h1">
<Variable name="header.font" description="Font" type="font"
default="normal normal 60px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="header.text.color" description="Title Color" type="color" default="#3399bb" />
</Group>
<Group description="Blog Description" selector=".header .description">
<Variable name="description.text.color" description="Description Color" type="color"
default="#777777" />
</Group>
<Group description="Tabs Text" selector=".tabs-inner .widget li a">
<Variable name="tabs.font" description="Font" type="font"
default="normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="tabs.text.color" description="Text Color" type="color" default="#999999"/>
<Variable name="tabs.selected.text.color" description="Selected Color" type="color" default="#000000"/>
</Group>
<Group description="Tabs Background" selector=".tabs-outer .PageList">
<Variable name="tabs.background.color" description="Background Color" type="color" default="#f5f5f5"/>
<Variable name="tabs.selected.background.color" description="Selected Color" type="color" default="#eeeeee"/>
</Group>
<Group description="Post Title" selector="h3.post-title, .comments h4">
<Variable name="post.title.font" description="Font" type="font"
default="normal normal 22px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
</Group>
<Group description="Date Header" selector=".date-header">
<Variable name="date.header.color" description="Text Color" type="color"
default="#000000"/>
<Variable name="date.header.background.color" description="Background Color" type="color"
default="transparent"/>
</Group>
<Group description="Post Footer" selector=".post-footer">
<Variable name="post.footer.text.color" description="Text Color" type="color" default="#666666"/>
<Variable name="post.footer.background.color" description="Background Color" type="color"
default="#f9f9f9"/>
<Variable name="post.footer.border.color" description="Shadow Color" type="color" default="#eeeeee"/>
</Group>
<Group description="Gadgets" selector="h2">
<Variable name="widget.title.font" description="Title Font" type="font"
default="normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="widget.title.text.color" description="Title Color" type="color" default="#000000"/>
<Variable name="widget.alternate.text.color" description="Alternate Color" type="color" default="#999999"/>
</Group>
<Group description="Images" selector=".main-inner">
<Variable name="image.background.color" description="Background Color" type="color" default="#ffffff"/>
<Variable name="image.border.color" description="Border Color" type="color" default="#eeeeee"/>
<Variable name="image.text.color" description="Caption Text Color" type="color" default="#000000"/>
</Group>
<Group description="Accents" selector=".content-inner">
<Variable name="body.rule.color" description="Separator Line Color" type="color" default="#eeeeee"/>
<Variable name="tabs.border.color" description="Tabs Border Color" type="color" default="transparent"/>
</Group>
<Variable name="body.background" description="Body Background" type="background"
color="#6fa8dc" default="$(color) none repeat scroll top left"/>
<Variable name="body.background.override" description="Body Background Override" type="string" default=""/>
<Variable name="body.background.gradient.cap" description="Body Gradient Cap" type="url"
default="url(http://www.blogblog.com/1kt/simple/gradients_light.png)"/>
<Variable name="body.background.gradient.tile" description="Body Gradient Tile" type="url"
default="url(http://www.blogblog.com/1kt/simple/body_gradient_tile_light.png)"/>
<Variable name="content.background.color.selector" description="Content Background Color Selector" type="string" default=".content-inner"/>
<Variable name="content.padding" description="Content Padding" type="length" default="10px"/>
<Variable name="content.padding.horizontal" description="Content Horizontal Padding" type="length" default="10px"/>
<Variable name="content.shadow.spread" description="Content Shadow Spread" type="length" default="40px"/>
<Variable name="content.shadow.spread.webkit" description="Content Shadow Spread (WebKit)" type="length" default="5px"/>
<Variable name="content.shadow.spread.ie" description="Content Shadow Spread (IE)" type="length" default="10px"/>
<Variable name="main.border.width" description="Main Border Width" type="length" default="0"/>
<Variable name="header.background.gradient" description="Header Gradient" type="url" default="none"/>
<Variable name="header.shadow.offset.left" description="Header Shadow Offset Left" type="length" default="-1px"/>
<Variable name="header.shadow.offset.top" description="Header Shadow Offset Top" type="length" default="-1px"/>
<Variable name="header.shadow.spread" description="Header Shadow Spread" type="length" default="1px"/>
<Variable name="header.padding" description="Header Padding" type="length" default="30px"/>
<Variable name="header.border.size" description="Header Border Size" type="length" default="1px"/>
<Variable name="header.bottom.border.size" description="Header Bottom Border Size" type="length" default="1px"/>
<Variable name="header.border.horizontalsize" description="Header Horizontal Border Size" type="length" default="0"/>
<Variable name="description.text.size" description="Description Text Size" type="string" default="140%"/>
<Variable name="tabs.margin.top" description="Tabs Margin Top" type="length" default="0" />
<Variable name="tabs.margin.side" description="Tabs Side Margin" type="length" default="30px" />
<Variable name="tabs.background.gradient" description="Tabs Background Gradient" type="url"
default="url(http://www.blogblog.com/1kt/simple/gradients_light.png)"/>
<Variable name="tabs.border.width" description="Tabs Border Width" type="length" default="1px"/>
<Variable name="tabs.bevel.border.width" description="Tabs Bevel Border Width" type="length" default="1px"/>
<Variable name="date.header.padding" description="Date Header Padding" type="string" default="inherit"/>
<Variable name="date.header.letterspacing" description="Date Header Letter Spacing" type="string" default="inherit"/>
<Variable name="date.header.margin" description="Date Header Margin" type="string" default="inherit"/>
<Variable name="post.margin.bottom" description="Post Bottom Margin" type="length" default="25px"/>
<Variable name="image.border.small.size" description="Image Border Small Size" type="length" default="2px"/>
<Variable name="image.border.large.size" description="Image Border Large Size" type="length" default="5px"/>
<Variable name="page.width.selector" description="Page Width Selector" type="string" default=".region-inner"/>
<Variable name="page.width" description="Page Width" type="string" default="auto"/>
<Variable name="main.section.margin" description="Main Section Margin" type="length" default="15px"/>
<Variable name="main.padding" description="Main Padding" type="length" default="15px"/>
<Variable name="main.padding.top" description="Main Padding Top" type="length" default="30px"/>
<Variable name="main.padding.bottom" description="Main Padding Bottom" type="length" default="30px"/>
<Variable name="paging.background"
color="#ffffff"
description="Background of blog paging area" type="background"
default="transparent none no-repeat scroll top center"/>
<Variable name="footer.bevel" description="Bevel border length of footer" type="length" default="0"/>
<Variable name="mobile.background.overlay" description="Mobile Background Overlay" type="string"
default="transparent none repeat scroll top left"/>
<Variable name="mobile.background.size" description="Mobile Background Size" type="string" default="auto"/>
<Variable name="mobile.button.color" description="Mobile Button Color" type="color" default="#ffffff" />
<Variable name="startSide" description="Side where text starts in blog language" type="automatic" default="left"/>
<Variable name="endSide" description="Side where text ends in blog language" type="automatic" default="right"/>
*/
/* Content
----------------------------------------------- */
body {
font: normal normal 12px Verdana, Geneva, sans-serif;
color: #000000;
background: #6fa8dc none repeat scroll top left;
padding: 0 0 0 0;
}
html body .region-inner {
min-width: 0;
max-width: 100%;
width: auto;
}
a:link {
text-decoration:none;
color: #33aaff;
}
a:visited {
text-decoration:none;
color: #33aaff;
}
a:hover {
text-decoration:underline;
color: #33aaff;
}
.body-fauxcolumn-outer .fauxcolumn-inner {
background: transparent none repeat scroll top left;
_background-image: none;
}
.body-fauxcolumn-outer .cap-top {
position: absolute;
z-index: 1;
height: 400px;
width: 100%;
background: #6fa8dc none repeat scroll top left;
}
.body-fauxcolumn-outer .cap-top .cap-left {
width: 100%;
background: transparent none repeat-x scroll top left;
_background-image: none;
}
.content-outer {
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .15);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .15);
-goog-ms-box-shadow: 0 0 0 #333333;
box-shadow: 0 0 0 rgba(0, 0, 0, .15);
margin-bottom: 1px;
}
.content-inner {
padding: 10px 40px;
}
.content-inner {
background-color: #ffffff;
}
/* Header
----------------------------------------------- */
.header-outer {
background: transparent none repeat-x scroll 0 -400px;
_background-image: none;
}
.Header h1 {
font: normal normal 40px 'Courier New', Courier, FreeMono, monospace;
color: #000000;
text-shadow: 0 0 0 rgba(0, 0, 0, .2);
}
.Header h1 a {
color: #000000;
}
.Header .description {
font-size: 18px;
color: #888888;
}
.header-inner .Header .titlewrapper {
padding: 22px 0;
}
.header-inner .Header .descriptionwrapper {
padding: 0 0;
}
/* Tabs
----------------------------------------------- */
.tabs-inner .section:first-child {
border-top: 0 solid #dddddd;
}
.tabs-inner .section:first-child ul {
margin-top: -1px;
border-top: 1px solid #dddddd;
border-left: 1px solid #dddddd;
border-right: 1px solid #dddddd;
}
.tabs-inner .widget ul {
background: transparent none repeat-x scroll 0 -800px;
_background-image: none;
border-bottom: 1px solid #dddddd;
margin-top: 0;
margin-left: -30px;
margin-right: -30px;
}
.tabs-inner .widget li a {
display: inline-block;
padding: .6em 1em;
font: normal normal 12px Verdana, Geneva, sans-serif;
color: #000000;
border-left: 1px solid #ffffff;
border-right: 1px solid #dddddd;
}
.tabs-inner .widget li:first-child a {
border-left: none;
}
.tabs-inner .widget li.selected a, .tabs-inner .widget li a:hover {
color: #000000;
background-color: #eeeeee;
text-decoration: none;
}
/* Columns
----------------------------------------------- */
.main-outer {
border-top: 0 solid transparent;
}
.fauxcolumn-left-outer .fauxcolumn-inner {
border-right: 1px solid transparent;
}
.fauxcolumn-right-outer .fauxcolumn-inner {
border-left: 1px solid transparent;
}
/* Headings
----------------------------------------------- */
h2 {
margin: 0 0 1em 0;
font: normal bold 11px 'Trebuchet MS',Trebuchet,Verdana,sans-serif;
color: #000000;
text-transform: uppercase;
}
/* Widgets
----------------------------------------------- */
.widget .zippy {
color: #999999;
text-shadow: 2px 2px 1px rgba(0, 0, 0, .1);
}
.widget .popular-posts ul {
list-style: none;
}
/* Posts
----------------------------------------------- */
.date-header span {
background-color: #bbbbbb;
color: #ffffff;
padding: 0.4em;
letter-spacing: 3px;
margin: inherit;
}
.main-inner {
padding-top: 35px;
padding-bottom: 65px;
}
.main-inner .column-center-inner {
padding: 0 0;
}
.main-inner .column-center-inner .section {
margin: 0 1em;
}
.post {
margin: 0 0 45px 0;
}
h3.post-title, .comments h4 {
font: normal normal 22px Verdana, Geneva, sans-serif;
margin: .75em 0 0;
}
.post-body {
font-size: 110%;
line-height: 1.4;
position: relative;
}
.post-body img, .post-body .tr-caption-container, .Profile img, .Image img,
.BlogList .item-thumbnail img {
padding: 2px;
background: #ffffff;
border: 1px solid #eeeeee;
-moz-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
-webkit-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
}
.post-body img, .post-body .tr-caption-container {
padding: 5px;
}
.post-body .tr-caption-container {
color: #000000;
}
.post-body .tr-caption-container img {
padding: 0;
background: transparent;
border: none;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
box-shadow: 0 0 0 rgba(0, 0, 0, .1);
}
.post-header {
margin: 0 0 1.5em;
line-height: 1.6;
font-size: 90%;
}
.post-footer {
margin: 20px -2px 0;
padding: 5px 10px;
color: #666666;
background-color: #eeeeee;
border-bottom: 1px solid #eeeeee;
line-height: 1.6;
font-size: 90%;
}
#comments .comment-author {
padding-top: 1.5em;
border-top: 1px solid transparent;
background-position: 0 1.5em;
}
#comments .comment-author:first-child {
padding-top: 0;
border-top: none;
}
.avatar-image-container {
margin: .2em 0 0;
}
#comments .avatar-image-container img {
border: 1px solid #eeeeee;
}
/* Accents
---------------------------------------------- */
.section-columns td.columns-cell {
border-left: 1px solid transparent;
}
.blog-pager {
background: transparent url(//www.blogblog.com/1kt/simple/paging_dot.png) repeat-x scroll top center;
}
.blog-pager-older-link, .home-link,
.blog-pager-newer-link {
background-color: #ffffff;
padding: 5px;
}
.footer-outer {
border-top: 1px dashed #bbbbbb;
}
/* Mobile
----------------------------------------------- */
body.mobile  {
background-size: auto;
}
.mobile .body-fauxcolumn-outer {
background: transparent none repeat scroll top left;
}
.mobile .body-fauxcolumn-outer .cap-top {
background-size: 100% auto;
}
.mobile .content-outer {
-webkit-box-shadow: 0 0 3px rgba(0, 0, 0, .15);
box-shadow: 0 0 3px rgba(0, 0, 0, .15);
padding: 0 0;
}
body.mobile .AdSense {
margin: 0 -0;
}
.mobile .tabs-inner .widget ul {
margin-left: 0;
margin-right: 0;
}
.mobile .post {
margin: 0;
}
.mobile .main-inner .column-center-inner .section {
margin: 0;
}
.mobile .date-header span {
padding: 0.1em 10px;
margin: 0 -10px;
}
.mobile h3.post-title {
margin: 0;
}
.mobile .blog-pager {
background: transparent none no-repeat scroll top center;
}
.mobile .footer-outer {
border-top: none;
}
.mobile .main-inner, .mobile .footer-inner {
background-color: #ffffff;
}
.mobile-index-contents {
color: #000000;
}
.mobile-link-button {
background-color: #33aaff;
}
.mobile-link-button a:link, .mobile-link-button a:visited {
color: #ffffff;
}
.mobile .tabs-inner .section:first-child {
border-top: none;
}
.mobile .tabs-inner .PageList .widget-content {
background-color: #eeeeee;
color: #000000;
border-top: 1px solid #dddddd;
border-bottom: 1px solid #dddddd;
}
.mobile .tabs-inner .PageList .widget-content .pagelist-arrow {
border-left: 1px solid #dddddd;
}
/*indent headers to left*/
#header{   /*blog header*/
margin-left: -9px;
}
#header .descriptionwrapper{ /*blog description*/
padding-left: 20px;
}
h3.post-title{  /*post header*/
margin-left: -20px;
}
h3.post-title a{ /*recolor post header link*/
color: black;
}
h2.date-header{ /*post header date*/
margin-left: -9px;
}
/*content settings*/
.post-body{
text-align:justify;
text-justify: newspaper;
}
.post-body s,
.post-body strike{
color: gray;
}
.post-body code{
/*padding-left: 1em;
padding-right: 1em;*/
}
.post-body img{
display : block;
float   : left;
clear   : right;
margin  : 1em;
}
/*questions and answers */
.post-body dl.qa>dt{
font-weight: normal;
}
.post-body dl.qa>dd{
margin-left: 0;
}
.post-body dl.qa>dt::before {
content:"В:";
font-weight: bold;
margin-right: 1em;
color: darkred;
}
.post-body dl.qa>dd::before{
content:"О:";
font-weight: bold;
margin-right: 1em;
color: darkgreen;
}
/* tables */
.post-body table{
border: none;/*1px dotted black;*/
border-collapse: collapse;
border-spacing: 0px;
}
.post-body table th{
text-align:center;
}
.post-body table td, th{
border: 1px dotted gray;
padding: 0.5em;
}
/*in-post headers */
.post-body h2{
margin-top: 3em;
margin-bottom 1.5em;
margin-left: -20px;
font-family: Verdana;
}
.post-body em.epigraph{
padding-left:40%;
display:block;
}
--></style>
<style id='template-skin-1' type='text/css'><!--
body {
min-width: 1040px;
}
.content-outer, .content-fauxcolumn-outer, .region-inner {
min-width: 1040px;
max-width: 1040px;
_width: 1040px;
}
.main-inner .columns {
padding-left: 0;
padding-right: 260px;
}
.main-inner .fauxcolumn-center-outer {
left: 0;
right: 260px;
/* IE6 does not respect left and right together */
_width: expression(this.parentNode.offsetWidth -
parseInt("0") -
parseInt("260px") + 'px');
}
.main-inner .fauxcolumn-left-outer {
width: 0;
}
.main-inner .fauxcolumn-right-outer {
width: 260px;
}
.main-inner .column-left-outer {
width: 0;
right: 100%;
margin-left: -0;
}
.main-inner .column-right-outer {
width: 260px;
margin-right: -260px;
}
#layout {
min-width: 0;
}
#layout .content-outer {
min-width: 0;
width: 800px;
}
#layout .region-inner {
min-width: 0;
width: auto;
}
--></style>
<link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=410416665291724878&amp;zx=70030251-c9c8-424a-9a64-7817a4864b31' media='none' onload='if(media!=&#39;all&#39;)media=&#39;all&#39;' rel='stylesheet'/><noscript><link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=410416665291724878&amp;zx=70030251-c9c8-424a-9a64-7817a4864b31' rel='stylesheet'/></noscript>

</head>
<body class='loading'>
<div class='navbar section' id='navbar'><div class='widget Navbar' data-version='1' id='Navbar1'><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener('load',
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
  </script>
<div id="navbar-iframe-container"></div>
<script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>
<script type="text/javascript">
      gapi.load("gapi.iframes:gapi.iframes.style.bubble", function() {
        if (gapi.iframes && gapi.iframes.getContext) {
          gapi.iframes.getContext().openChild({
              url: 'https://www.blogger.com/navbar.g?targetBlogID\x3d410416665291724878\x26blogName\x3d%3E%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B5+%D0%B7%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8\x26publishMode\x3dPUBLISH_MODE_HOSTED\x26navbarType\x3dLIGHT\x26layoutType\x3dLAYOUTS\x26searchRoot\x3dhttps://dev.cheremin.info/search\x26blogLocale\x3dru\x26v\x3d2\x26homepageUrl\x3dhttps://dev.cheremin.info/\x26vt\x3d-6160567955490088475',
              where: document.getElementById("navbar-iframe-container"),
              id: "navbar-iframe"
          });
        }
      });
    </script><script type="text/javascript">
(function() {
var script = document.createElement('script');
script.type = 'text/javascript';
script.src = '//pagead2.googlesyndication.com/pagead/js/google_top_exp.js';
var head = document.getElementsByTagName('head')[0];
if (head) {
head.appendChild(script);
}})();
</script>
</div></div>
<div class='body-fauxcolumns'>
<div class='fauxcolumn-outer body-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content'>
<div class='content-fauxcolumns'>
<div class='fauxcolumn-outer content-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content-outer'>
<div class='content-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left content-fauxborder-left'>
<div class='fauxborder-right content-fauxborder-right'></div>
<div class='content-inner'>
<header>
<div class='header-outer'>
<div class='header-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left header-fauxborder-left'>
<div class='fauxborder-right header-fauxborder-right'></div>
<div class='region-inner header-inner'>
<div class='header section' id='header'><div class='widget Header' data-version='1' id='Header1'>
<div id='header-inner'>
<div class='titlewrapper'>
<h1 class='title'>
&gt;рабочие заметки
</h1>
</div>
<div class='descriptionwrapper'>
<p class='description'><span>Рабочие заметки java-программиста. Производительность, concurrency, прочие извращения</span></p>
</div>
</div>
</div></div>
</div>
</div>
<div class='header-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</header>
<div class='tabs-outer'>
<div class='tabs-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left tabs-fauxborder-left'>
<div class='fauxborder-right tabs-fauxborder-right'></div>
<div class='region-inner tabs-inner'>
<div class='tabs no-items section' id='crosscol'></div>
<div class='tabs no-items section' id='crosscol-overflow'></div>
</div>
</div>
<div class='tabs-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='main-outer'>
<div class='main-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left main-fauxborder-left'>
<div class='fauxborder-right main-fauxborder-right'></div>
<div class='region-inner main-inner'>
<div class='columns fauxcolumns'>
<div class='fauxcolumn-outer fauxcolumn-center-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-left-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-right-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<!-- corrects IE6 width calculation -->
<div class='columns-inner'>
<div class='column-center-outer'>
<div class='column-center-inner'>
<div class='main section' id='main'><div class='widget Blog' data-version='1' id='Blog1'>
<div class='blog-posts hfeed'>

          <div class="date-outer">
        
<h2 class='date-header'><span>20 августа 2018 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='8720589222529936795'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2018/08/blog-post.html'>Оценки квантилей распределений потока данных</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-8720589222529936795'>
<script src="//tex.s2cms.ru/latex.js"></script><br />
Последнюю неделю копаю алгоритмы оценок для квантилей выборок. Началось все с префетчинга: есть хранилище данных на диске, часть из них кэшируется в памяти, и надо бы успевать кэшировать предварительно с такой скоростью, чтобы клиентам не приходилось ожидать ввода-вывода. Доступ последовательный, так что все сводится к вопросу "сколько страниц загрузить в текущем раунде упреждающего чтения". И обычно в таких случаях я вижу что-то вроде<br />
<pre class="brush: java">int estimatePagesToPrefetch(...){
   return 4;//carefully chosen
}
</pre>Иногда (реже) что-то вроде<br />
<pre class="brush: java">int estimatePagesToPrefetch(int pagesReadSinceLastPrefetch){
   return ema( pagesReadSinceLastPrefetch ) * 3/2; //150% is enough for everyone
}
</pre>И я сам так пишу, но в этот раз душа физика-теоретика захотела бОльшего: можно ли обойтись без с потолка взятых констант? Проблема с константами не только в том, что они непонятно откуда взялись (хотя многие да). Еще одна проблема, что непонятно даже, <i>из каких соображений</i> они взялись. Вот эти 4 страницы, или 150% от средней скорости использования &#8212; <i>какого внешнего результата автор от них ожидал</i>? По какому критерию он их выбрал (если вообще выбирал)?<br />
<br />
Ну и я спросил себя: а по какому критерию я бы выбирал параметры префетчинга? Мне кажется, префетчинг должен с заданной вероятностью (90%, 95%, 99%...) опережать использование. Это критерий, понятный человеку, он легко пересчитывается в другие latency-oriented критерии. И чтобы его реализовать, нужно оценить соответствующий <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B0%D0%BD%D1%82%D0%B8%D0%BB%D1%8C">квантиль</a> распределения величин <code>pagesReadSinceLastPrefetch</code>.<br />
<br />
И я начал искать какой-нибудь простой и быстрый способ оценить n-ый квантиль распределения по потоку сэмплов из него. BigData сейчас в моде, так что статей обнаружилось много, но алгоритмы меня не порадовали:<br />
<ol><li>Cложные &#8212; не напишешь за 5 минут, если тебе вдруг понадобилось оценить 0.95-й квантиль. </li>
<li>Cами по себе не приспосабливаются к нестационарному распределению: если распределение данных меняется со временем (а в реальных сценариях это почти всегда так), то приходится делать дополнительные усложнения</li>
</ol>Но потом я наткнулся статью <a href="https://pdfs.semanticscholar.org/dae2/88ae2e07adb3ede0567c9b5bf0ea35030375.pdf">Frugal Streaming for Estimating Quantiles</a>. И в ней излагаются два совершенно замечательных, очень экономных стохастических алгоритма оценки квантилей потока данных.<br />
<br />
Замечательные они вот почему:<br />
<ol><li>Очень бережливо (frugal) относятся к памяти. Frugal1U использует для хранения состояния одну-единственную ячейку памяти (!), Frugal2U использует 2 ячейки + 1 бит. Строго говоря есть еще один конфигурационный параметр, да нужен генератор случайных чисел, у которого есть состояние, и неочевидно, считать ли это все "состоянием алгоритма", или относить к "общей памяти программы". Но даже в самом строгом варианте получается 3-4 ячейки памяти.</li>
<li>Очень простые, как по количеству инструкций, так и когнитивно. Наверное, самое сложное, это поверить, что это вообще может работать, и понять, почему это может довольно хорошо работать. (Я потратил несколько вечеров, чтобы разобраться, почему они работают, и пару недель, пытаясь придумать что-то лучшее &#8212; и все еще особо не преуспел). </li>
<li>Автоматически, безо всяких дополнительных усложнений, адаптируются к нестационарностям распределения</li>
<li>Не используют никаких априорных предположений о виде распределения данных в потоке &#8212; только само определение квантиля. С одной стороны это недостаток: вкупе с ограничением по используемой памяти получается не очень быстрая сходимость и довольно большая погрешность. А с другой это дает очень высокую устойчивость: "смутить" алгоритм каким-то сложным распределением практически невозможно. Они как в том анекдоте: медленно спускаются с горы, и делают свою работу</li>
</ol>Как я понял, авторы разрабатывали эти алгоритмы для чего-то вроде встраиваемых сенсоров, где память и вычислительная мощность очень ограничены, а поток данных может быть большим и зашумленным, и его нужно как-то предобработать, прежде чем выдавать наружу. Но мне кажется, что таким простым и устойчивым алгоритмам найдется применение и много где еще &#8212; хотя бы и для построения регуляторов/петель обратной связи. <br />
<h2>Frugal1U</h2>Идея алгоритма настолько проста, что кажется, тебя разыгрывают: пусть нужно оценить 50% квантиль (медиану). Медиана &#8212; это такое X, что элементы (сэмплы) из потока будут равновероятно оказываться как справа, так и слева от X. Если относительно X сэмплы с одной стороны выпадают чаще, чем с другой &#8212; значит X это не медиана, а настоящая медиана лежит как раз с той стороны, куда сэмплы попадают чаще. Так возьмем любое X за начальное приближение, выберем небольшой шаг <code>step</code>, и будем на каждый приходящий сэмпл обновлять <code>X[i+1] -> X[i] +/- step</code>, смотря в какую сторону от X попал текущий сэмпл. Статистически мы будем чаще делать шаг <i>к медиане</i>, чем <i>от нее</i>, так что рано или поздно мы до нее дошагаем, и дальше будем топтаться около.<br />
<pre class="brush: python">step = 1
X    = 0   # initial estimation of median
for x in stream:
    if x > X:      
        X += step
    elif x &lt; X: 
        X -= step
</pre>Ок, с медианой понятно (понятно же?). А если я хочу 0.9-квантиль? Значение 0.9 квантиля, X<sub>0.9</sub>, это такая величина, что элементы из потока данных будут с вероятностью 0.9 падать слева от него, и с вероятностью 0.1 справа. Тут авторы предлагают буквально "...выльем чайник на плиту и сведем задачу к предыдущей": давайте <i>сгенерируем</i> дополнительную булевую случайную величину, с "обратным" распределением (0.1 к 0.9), и скомбинируем ее с вероятностью попадания справа-слева (через AND). Для этой комбинированной случайной величины значение X<sub>0.9</sub> будет как-бы-медианой, а медиану мы уже искать умеем:<br />
<pre class="brush: python">step = 1
Q    = 0.9 # quantile we're about to estimate
Xq   = 0   # initial estimation of Q-th quantile
for x in stream:
    r = random()                   # r in [0,1]
    if x > Xq and r &lt; Q:        # Prob(x > Xq)=0.1, Prob(r < Q) = 0.9
        Xq += step
    elif val &lt; Xq and r > Q:    # Prob(x < Xq)=0.9, Prob(r > Q) = 0.1
        Xq -= step
</pre><em><br />
(Без генератора случайных чисел можно и обойтись: достаточно заметить, что матожидание величины шага вправо будет <code>0.1*step</code>, а влево <code>0.9*step</code>. Если заменить "шаг <code>step</code> с вероятностью 0.1" на "шаг <code>0.1*step</code> всегда", то алгоритм станет проще и ГСЧ будет не нужен. Странно, что авторы статьи не отметили такой возможности: в тестах, что я делал, оба алгоритма ведут себя практически неразличимо, и только при увеличении можно различить чуть разное поведение на уровне отдельных шагов. Мое предположение, что просто анализ такого алгоритма сложнее, и авторы не стали заморачиваться)</em><br />
<br />
Алгоритм выглядит подозрительно просто, у меня сразу возникли два вопроса:<br />
1. Как быстро он сходится?<br />
2. Насколько стабильно?<br />
<br />
Про <b>скорость</b> сходимости можно сразу заметить, что алгоритм двигает текущую оценку не более чем на step за итерацию. Так что если между текущей оценкой и истинным значением квантиля дистанция D, то алгоритм сойдется точно не раньше, чем за <code>N=D/step</code> шагов. Более аккуратный анализ (см статью) дает такую оценку: за не более чем $$N\frac{|ln(1-P)|}{e}$$ шагов алгоритм с вероятностью P хотя бы раз попадет в e-окрестность квантиля. Оценка отличается от N только на константу $$\frac{|ln(1-P)|}{e}$$, но константа эта довольно не маленькая: если хочется с вероятностью 90% попасть в 5% окрестность квантиля, то ждать придется "всего лишь" не больше чем <code>N*|ln(1-0.9)|/0.05 =~ 46*N</code> шагов.<br />
<br />
Почему так медленно: пусть истинное значение квантиля Q это точка X. Алгоритм сейчас находится в точке X' которая является квантилем Q' (т.е $$Pr(x&lt;X') = Q'$$). Тогда матожидание смещения на текущем шаге будет просто <code>step*(Q'-Q)</code>. Конкретный закон эволюции матожидания отсюда не получишь &#8212; нужно знать вид функции распределения P(X) &#8212; но и по общему виду понятно, что приближение (матожидания) к истинному значению квантиля будет асимптотическим: чем ближе подходим, тем медленнее идем. Если бы надо было "дошагать" матожиданием, то ждать пришлось бы вообще бесконечно, но ближе к концу существенную роль начинает играть накопившийся статистический разброс вокруг среднего: за счет него ждать бесконечно долго нам почти наверняка не придется. <br />
<br />
Теперь про <b>стабильность</b>: поскольку алгоритм статистический, то даже сойдясь к значению квантиля он не остановится, а будет продолжать топтаться вокруг. Насколько далеко вокруг?<br />
<br />
В первом приближении в окрестности заданного квантиля алгоритм делает шаги вправо и влево с одинаковой вероятностью. Это похоже на одномерное броуновское движение, про которое известно, что среднее расстояние от начала пропорционально корню из количества шагов. Что звучит довольно хреново, потому что означает, что со временем наша оценка уплывет сколь угодно далеко. Но это верно только вблизи целевого квантиля: чем дальше алгоритм от него отходит, тем больше будут отличаться вероятности шагнуть "от" и "к" &#8212; и вероятность шагнуть ближе к квантилю будет возрастать. В статье оценивают это более аккуратно, и получается такая оценка: <br />
<br />
<em>Пусть δ это максимальное значение (дискретной) функции распределения элементов из потока (т.е. максимальная вероятность выпадения какого-то конкретного значения). Тогда вероятность того, что за N шагов алгоритм отклонится от квантиля Q больше, чем на ΔQ оценивается так: <br />
$$Pr(|Q(N)-Q| > \Delta Q) <= N e^-\frac{(2\Delta Q)^2}{\delta}$$
</em><br />
<br />
Например: если в потоке 1000 <i>разных равновероятных</i> значений, то <code>δ=1/1000</code>, и если мы хотим ограничиться 5% отклонением от квантиля, то можем быть спокойны: за пределы 5% алгоритм вылезет не чаще, за 10000 шагов. А вот если потребовать 4% коридор, то за него мы будем вылезать уже за 300-400 шагов. <br />
<br />
Мне обе оценки показались не очень интуитивны (особенно вторая). Так что я посчитал и численно смоделировал эволюцию распределения вероятностей результатов алгоритма по шагам. Для стабильного распределения входных данных алгоритм сходится к стабильному же распределению вокруг истинной медианы &#8212; т.е. дисперсия вырастет до какой-то величины, и дальше расти не будет. На графике результат симуляции для самого простого, равномерного распределения входных данных U[0..128), и шага в 1. Красным показана настоящая медиана (=64), синим &#8212; наиболее вероятный результат алгоритма, а пунктир очерчивает интервал, в который алгоритм попадет с 90% вероятностью. <br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-_VuUMGA5yr4/W3nKAjFG6YI/AAAAAAAAFQc/TEuWbvLqABUTrtp5M4rTzxXlATUBJvzGQCLcBGAs/s1600/frugal1u_median.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="471" data-original-width="771" src="https://1.bp.blogspot.com/-_VuUMGA5yr4/W3nKAjFG6YI/AAAAAAAAFQc/TEuWbvLqABUTrtp5M4rTzxXlATUBJvzGQCLcBGAs/s1600/frugal1u_median.png" /></a></div><br />
Видно, что наиболее вероятное значение даже после 400 шагов все еще отличается от настоящей медианы, а вот верхняя граница 90% интервала пересекла медиану уже на 120 шаге. На следующем графике &#8212; вероятность достижения медианы к шагу N:<br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-yB8rovMgJqw/W3nTw7rMm0I/AAAAAAAAFRA/t_cM2zc7WnMTybKly1jit_7RM_RzXtHrwCLcBGAs/s1600/asymptotic_P_400.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="459" data-original-width="779" src="https://2.bp.blogspot.com/-yB8rovMgJqw/W3nTw7rMm0I/AAAAAAAAFRA/t_cM2zc7WnMTybKly1jit_7RM_RzXtHrwCLcBGAs/s1600/asymptotic_P_400.png" /></a></div><br />
Т.е. минимально мы могли бы дошагать до медианы за 64 шага, но с вероятностью 20% дошагаем только к 120-му шагу, с вероятностью 60% к 150, а к 200-му шагу уже почти наверняка дошагаем. Сильно лучше, чем показывает оценка из статьи (там нам обещали не более чем за 40*N), ну так равномерное распределение и не самый сложный случай. С другой стороны разброс вокруг медианы довольно приличный: с вероятностью 10% мы обнаружим алгоритм за пределами интервала (35%, 65%). <br />
<br />
А если пересчитать все то же самое с разбросом входных данных в 8 раз больше (0..1024) и тем же шагом 1, то время 90% достижения медианы увеличится до 1700 шагов, зато 90% интервал вокруг медианы сожмется до (45%, 55%)<br />
<br />
Виден компромисс между скоростью сходимости и стабильностью. В первом случае шаг составлял 1/64 от дистанции до медианы, и алгоритм почти сошелся за 200 шагов, и держит медиану с точностью +/- 15%. Во втором случае шаг был 1/512 от дистанции до медианы, и алгоритм почти сошелся за 1700 шагов, и держит медиану с точностью +/-5%. <br />
<br />
Тут же возникает идея подстраивать шаг: начинать с большого, и постепенно уменьшать, как это делают во алгоритмах имитации отжига. Но это подходит только если мы знаем, что распределение стационарно, если же оно меняется со временем, то уменьшая шаг мы будем одновременно замедлять подстройку к изменениям в распределении. Хорошо бы менять шаг в зависимости от того, насколько мы далеко от цели &#8212; но как оценить, насколько мы далеко? Тут авторы достают свой второй козырь:<br />
<h2>Frugal2U</h2>Этот алгоритм расширяет предыдущий: основная логика та же, но к ней добавляется подстройка величины шага. Чтобы организовать подстройку, требуется еще одна ячейка памяти для хранения текущего шага, <code>currentStep</code>, и еще один бит <code>sign</code> для хранения <i>направления</i> предыдущего шага. И идея, снова, очень простая: давайте запоминать, в каком направлении мы шагнули (<code>sign</code>), и увеличивать текущий шаг каждый раз, как мы делаем следующий шаг в одном и том же направлении, что и предыдущий:<br />
<pre class="brush: python">step = 1
currentStep=step
sign = 1
Q    = 0.9       # quantile we're about to estimate
Xq   = 0         # initial estimation of Q-th quantile
for x in stream:
  r = np.random.random()
  if x < Xq and r > Q:
      currentStep -= sign * step
      Xq -= max(currentStep, step)
      if value > Xq:  # too much of adjustment
          currentStep += Xq - value
          Xq = value
      if sign > 0 and currentStep > step:          
          currentStep = step              # if sign was changed -> reset currentStep to minimum
      sign = -1
  elif x > Xq and r < Q:
      currentStep += sign * step
      Xq += max(currentStep, step)
      if value < Xq:  # too much of adjustment
          currentStep += value - Xq
          Xq = value
      if sign < 0 and currentStep > step:          
          currentStep = step             # if sign was changed -> reset currentStep to minimum
      sign = 1
</pre>(код выглядит громоздко, потому что довольно много места занимает обработка выходов за границы разумности)<br />
<br />
Почему это работает? На пальцах: если вероятность пойти в какую-то сторону один раз равна <code>P</code>, то вероятность пойти туда же N раз подряд &#8212; <code>P^N</code>, и с такой вероятностью шаг вырастет до <code>N*step</code>. Чем больше <code>P</code>, тем больше вероятность достичь бОльшего шага. Но в нашем алгоритме вероятность <code>P</code> зависит от расстояния до истинного значения квантиля: чем мы дальше от цели, тем больше вероятность шагнуть именно в ее сторону. <br />
<br />
Более количественно: пусть мы сделали N шагов в одну сторону подряд &#8212; вероятность этого <code>P^N</code>, и шаг вырос до максимума <code>N*step</code>, т.е. средний шаг <code>step*(N+1)/2</code>. То есть с вероятностью <code>P^N</code> мы шли со средним шагом <code>step*(N+1)/2</code>. Просуммируем по всем N (спонсор вычисления бесконечных сумм <a href="http://www.wolframalpha.com/">wolfram alpha</a>), и получим матожидание шага:<br />
$$E[D(P)] = step\cdot\sum_{i=1}^{\infty}P^i \frac{(i+1)}{2} = step\frac{(2-P)*P}{2(1-P)^2}$$<br />
Переводя на русский: схема "увеличиваем шаг пока идем в одну сторону" неявно задает вот такую зависимость среднего размера шага от дистанции до цели (целью у нас выступает медиана, <code>P=0.5</code>). <br />
<br />
Я построил на одном графике сразу две зависимости: <code>E[D(P)]</code> и <code>E[D(1-P)]</code>, потому что мы ведь из каждой точки можем пойти в обе стороны, и удобно сразу видеть, как меняется матожидание шага в одну, и в другую сторону<br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-n8LyHl0iCQQ/W3nKAt-UFaI/AAAAAAAAFQw/U98Onw074XIqmQ67GeH7jm5lHWyirci-wCPcBGAYYCw/s1600/E_D_P.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="438" data-original-width="752" src="https://3.bp.blogspot.com/-n8LyHl0iCQQ/W3nKAt-UFaI/AAAAAAAAFQw/U98Onw074XIqmQ67GeH7jm5lHWyirci-wCPcBGAYYCw/s1600/E_D_P.png" /></a></div><br />
Оба графика пересекаются в P=0.5 &#8212; это как раз стационарная точка, к которой алгоритм сходится. А вот по мере отклонения от 0.5 графики расходятся, и очень быстро: уже на расстоянии в 0.3 от равновесия средний шаг <i>в направлении равновесия</i> будет >10 единиц. То есть если мы на расстоянии 0.3 от медианы, то приближаться мы будем примерно десятикратными шагами. Похоже, несмотря на простоту, такая схема управления размером шага может вполне хорошо работать!<br />
<br />
(По мере приближения к 1 формула дает шаг равный бесконечности. Но сильно переживать по этому поводу не стоит: ведь получена в предположении, что P постоянно, т.е. мы стоим на месте. А чтобы шаг действительно рос, нам нужно двигаться &#8212; ведь шаг увеличивается только на 1 за итерацию. И как только мы начнем двигаться, то мы начнем и приближаться к истинному квантилю, а значит и P начнет отходить от 1, и приближаться к 0.5. Т.е. порвать вселенную нам не грозит, но набрать достаточно большой шаг можно &#8212; поэтому в алгоритме выше и есть ветки, проверяющие перехлест) <br />
<br />
Под конец пару примеров, как алгоритмы ведут себя на тестовых данных.<br />
Пример 1: оценка 80% квантиля на выборке из равномерного распределения. Красным показан "эталон" для сравнения &#8212; сглаженный "честный" квантиля на истории из последних 400 элементов:<br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-VLbzDHFnm0c/W3nKBwn_BZI/AAAAAAAAFQw/hnOOvZ3itdAhM1Ck3bG3RIgn1oXtpn-MgCPcBGAYYCw/s1600/frugals_uniform.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="438" data-original-width="777" src="https://1.bp.blogspot.com/-VLbzDHFnm0c/W3nKBwn_BZI/AAAAAAAAFQw/hnOOvZ3itdAhM1Ck3bG3RIgn1oXtpn-MgCPcBGAYYCw/s1600/frugals_uniform.png" /></a></div>Видно, насколько быстрее Frugal2U сходится к значению квантиля: почти так же хорошо, как и "честная" оценка квантиля по окну, при этом они гораздо меньше флуктуируют. Если же окно увеличить так, чтобы флуктуации пропали, то пострадает скорость сходимости. <br />
<br />
Пример 2: ступеньки + равномерное распределение. Здесь можно лучше рассмотреть скорости перехода &#8212; видно, насколько быстро перестраивается Frugal2U, насколько сильно запаздывает Frugal1U.<br />
<div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-QITS0Z9ql_4/W3nKBtAEafI/AAAAAAAAFQs/RrdEYUibqFojhVLiHaA6YTJq3XKWP9qZACPcBGAYYCw/s1600/frugals_heaviside_u.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="438" data-original-width="777" src="https://4.bp.blogspot.com/-QITS0Z9ql_4/W3nKBtAEafI/AAAAAAAAFQs/RrdEYUibqFojhVLiHaA6YTJq3XKWP9qZACPcBGAYYCw/s1600/frugals_heaviside_u.png" /></a></div><br />
У меня было гораздо больше примеров, но статья так выросла больше, чем я ожидал. Вот <a href="https://research.neustar.biz/2013/09/16/sketch-of-the-day-frugal-streaming/">здесь </a> хорошая статья на английском про те же алгоритмы, но еще и симуляция на javascript: можно прямо в браузере посмотреть, как они работают на разных распределениях <br />
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2018/08/blog-post.html' rel='bookmark' title='permanent link'><abbr class='published' title='2018-08-20T01:20:00+04:00'>1:20</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2018/08/blog-post.html#comment-form' onclick=''>0
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=8720589222529936795&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%20%D0%BA%D0%BE%D1%80%D0%BE%D0%BB%D0%B5%D0%B2%D0%B0%20%D0%BD%D0%B0%D1%83%D0%BA' rel='tag'>математика королева наук</a>,
<a href='https://dev.cheremin.info/search/label/%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B5%D0%B5' rel='tag'>рабочее</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>28 июля 2018 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='147224457700465737'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2018/07/blog-post_28.html'>Снова про конфигурацию</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-147224457700465737'>
Одна из проблем с тестированием конфигурации состоит в том, что нет готовой инфраструктуры<br />
<br />
Я имею в виду, что когда вы собираетесь написать тест для кода &mdash;  у вас уже многое есть. У вас есть какая-то доменная модель, у вас есть какие-то API, у вас есть какие-то builders/wizards/DSL. Да, поверх всего этого, обычно, все равно приходится дописать прослойку вспомогательного кода, предназначенного именно для тестирования (aka "test-harness"), но если основной код спроектирован и написан достаточно хорошо, то эта прослойка довольно тонкая. Условно, процентов 50-80 уже написано, и эти проценты очень облегчают начало.<br />
<br />
А вот когда вы начинаете писать тесты для конфигурации &mdash; у вас нет нихрена, или почти нихрена, кроме кучи текстовых файлов. И это сильно осложняет начало (и тормозит внедрение самой идеи).<br />
<br />
Да, везде можно найти свои плюсы: я приводил пример, как поверх примитивной структуры конфигов можно писать такие же примитивные тесты, бьющие по площадям ("все свойства, заканчивающиеся на .port, имеют в качестве значения целое число из диапазона доступных сетевых портов"). Но одними ковровыми бомбардировками каши не сваришь &mdash; рано или поздно появится желание (необходимость) проверить что-то конкретное и узкосфокусированное. <br />
<br />
И вот тут часто возникает барьер: попытка написать такой тест "с лету" приводит к монструозному спагетти-коду, глядя на который хочется перекреститься "не дай бог коллеги увидят". А создание обвязки, позволяющей писать более-менее понятные тесты &mdash;  выходит довольно дорого, потому что нет тех самых "50%-80%", и нет и наработанного опыта/понимания, как именно такую обвязку писать. Пару идей, как такую обвязку можно строить я в докладе давал, но все равно это каждый раз боль. <br />
<br />
В общем-то, я еще помню как похожие же проблемы возникали лет 10-15 назад с тестированием кода. И в этом случае решением стало распространение идей TDD &mdash; что тестирование это <i>неотъемлемая</i> часть разработки, и уже на стадии написания кода необходимо думать о том, как ты его будешь тестировать. Может быть, распространение аналогичной идеи test driven configuration со временем решит аналогичную проблему и для тестов конфигурации. А может быть просто все больше конфигурации будет в виде кода (а тестировать код мы уже научились, так что задача сводится к предыдущей) &mdash; мне, как программисту, это кажется более экономным решением
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2018/07/blog-post_28.html' rel='bookmark' title='permanent link'><abbr class='published' title='2018-07-28T14:11:00+04:00'>14:11</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2018/07/blog-post_28.html#comment-form' onclick=''>1 откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=147224457700465737&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5' rel='tag'>тестирование</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>12 июня 2018 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='4530157178755364018'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2018/06/configuration-as-code.html'>Configuration as code</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-4530157178755364018'>
По ходу подготовки своего доклада к Гейзенбагу мне несколько раз приходила в голову мысль: насколько было бы проще проверять конфигурацию, если бы она была не в текстовых файликах, а в java-коде! Насколько меньше всего нужно было бы валидировать &#8212; очень многое просто нельзя было бы сделать неправильно, потому что компилятор не пропустил бы. <br />
<br />
Сейчас мне кажется, что выносить конфигурацию приложения в текстовые файлы (в том числе xml/json/yaml&#8230;) &#8212; это сильно переоцененный прием. Настолько переоцененный, что он уже почти антипаттерн. Ну как синглетон &#8212; сам по себе вроде неплох, но был период, когда его пользовали где ни попадя, в хвост и гриву. Так же и с конфигурацией в текстовых файлах: якобы это дает гибкость, но эта гибкость на практике оказывается чаще вредной, чем полезной.<br />
<br />
И как раз когда я писал тесты для конфигурации &#8212; было очень заметно, насколько много в конфигурации <i>лишней</i> гибкости. Выясняется, что:<br />
<ol><li>Чтобы большая по объему конфигурация была управляемой &#8212; необходимы тесты</li>
<li>При написании тестов большую часть времени я занимаюсь тем, что &#8220;отменяю&#8221; всю гибкость вольного формата текстового файла. Изобретаю заново &#8212; в тестах &#8212; те вещи, которые уже есть в строго-типизированном языке программирования. </li>
</ol>Спрашивается: чего бы сразу не описывать конфигурацию на строго-типизированном языке?<br />
<br />
Для меня текстовые конфигурации это наследство tutorial-ов, на которых программисты учатся. Когда я по ним учился, то там в обязательном порядке все, что можно, выносилось в <code>.properties-файл</code>. Но в tutorial-е в этот файл попадает 3-5 свойств, а к концу туториала &#8212; файлов становится аж 2, для UAT и для PROD. В реальном приложении к третьему году разработки таких файлов 150, свойств в них 10000, и всё горит, и все в аду, но это так привычно, что кажется just a normal amount of hell.<br />
<br />
По-моему, правильная часть идеи здесь та, что все конфигурационные параметры из основного кода надо выносить. Это отдельная ответственность &#8212; задавать коду параметры. Но совершенно не обязательно этим параметрам лежать в примитивных, не валидируемых текстовых файлах. <br />
<br />
Это как с inversion of control/dependency-injection (очень близкая идея, кстати): ведь IoC/DI не равен тождественно <code>spring-app-context.xml</code>. Есть разные контейнеры, и разные форматы описания того, как контейнер должен собрать из компонентов приложение. <br />
<em style="padding-left:5em"><br />
Можно и вообще без контейнера: когда я работал в 1С над Матконструктором, я, как продвинутый хипстер, конечно же сплетал компоненты в приложение через spring. Но у матконструктора была версия в виде апплета, и тащить мегабайт .jar-ников спринга в апплет только ради фазы инициализации было за гранью добра. Поэтому (я уже не помню, кому пришла в голову эта гениальная идея) мы написали xslt, которая из spring-контекста генерировала .java-файл, делающий ровно то, что было задекларировано в контексте. Это оказалось довольно просто сделать, так как мы пользовались только базовыми возможностями spring. И хотя в релизной версии приложения не оставалось никаких следов  спринга, паттерн dependency injection сохранялся: сгенерированный класс был тем самым компонентом, ответственностью которого является собрать остальные компоненты в целое приложение.<br />
</em><br />
Возвращаясь к конфигурации: по-моему, для больших и/или сложно устроенных конфигураций управлять ими было бы гораздо проще, если они в виде кода, а не в виде текста.<br />
<br />
Как я себе вижу конфигурацию в коде? Пока не очень четко :) Скорее всего, как DSL-like API для конфигурирования приложения. Java не самый лучший выбор для создания DSL-ей, но даже ее скупыми средствами вполне можно создать такой набор builder-ов, что многие ошибки конфигурации просто не пройдут компиляцию (а еще ведь остаются рантайм-проверки). А если взять какой-нибудь Котлин, то можно написать и вовсе гарные DSL-и. При этом: <br />
<ol><li>Есть проверка типов (у нас же строго типизированный язык!)</li>
<li>Есть готовая вся система типов из доменной модели приложения, и ее можно расширить типами, специфичными для конфигурации.</li>
<li>Есть поддержка IDE: подсвечивание ошибочных элементов, подсказки допустимых, всплывающие подсказки с описанием смысла параметров и их допустимых значений (если вы позаботились об этом при написании АПИ), переименование/рефакторинг</li>
</ol>Поддержка IDE &#8212; это очень важный элемент, потому что он сильно сокращает время исправления ошибки. Например, есть немало решений для валидации конфигов, но валидация обнаруживает ошибки либо уже в рантайме, либо в тестировании, а ошибки компиляции современные IDE показывают сразу по ходу написания. А чтобы валидацию подхватила IDE &#8212; нужно постараться, и написать к ней специальный плагин, причем такой плагин нужен под каждый механизм валидации свой. <br />
<br />
Вообще, мне кажется, сейчас эта идея витает в воздухе &#8212; возможно, потому, что появился Kotlin, который очень близко интегрируется с java, но при этом имеет отличные возможности для DSL. Вот пара идейно-близких примеров, которые я нашел сходу: Александр Тарасов рассказывает, как он использует kotlin-DSL чтобы <a href="https://youtu.be/nftgdSQwkAE">конфигурировать эксперименты</a>, а Иван Осипов &#8212; как они DSL-ем <a href="https://habr.com/company/haulmont/blog/341402/">готовят параметры для параметризованных тестов</a>. 
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2018/06/configuration-as-code.html' rel='bookmark' title='permanent link'><abbr class='published' title='2018-06-12T19:19:00+04:00'>19:19</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2018/06/configuration-as-code.html#comment-form' onclick=''>11
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=4530157178755364018&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5' rel='tag'>тестирование</a>,
<a href='https://dev.cheremin.info/search/label/java' rel='tag'>java</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>20 мая 2018 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='3513544856743002049'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2018/05/java-2018.html'>"Тестирование конфигурации для java-разработчиков" (Гейзенбаг 2018, Петербург)</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-3513544856743002049'>
<br />
Меж тем я тут немного погрузился в тестирование &#8212; вплоть до того, что выступал на питерском Гейзенбаге с докладом про <a href="https://heisenbug-piter.ru/talks/2018/spb/3pnf97jpummk4yeociqwi0/">тестирование конфигурации</a>. Только вчера вернулся, а сегодня на сайте конференции уже выложили слайды. <br />
<br />
Тезисно: я рассказывал о том, что конфигурация это важная часть приложения &mdash; такая же важная, как код. Ошибки в конфигурации приводят к некорректной работе сервисов, и/или отказам в обслуживании &mdash; ровно так же, как и ошибки в коде.<br />
<br />
Но код приложения проходит множество проверок &#8212; начиная от компилятора (если вы, конечно, пишете на нормальных языках, а не на JavaScript), и кончая многими уровнями тестов. Конфигурация же, чаще всего, это просто какие-то текстовые файлы (properties, xml, yaml, json...), с очень вольным форматом, практически без валидации. Никаких автоматизированных тестов для нее, как правило, нет.<br />
<br />
К валидации конфигурационных параметров в самом приложении программисты тоже обычно относятся наплевательски &mdash; в большинстве приложений валидации либо нет, либо она довольно дырявая.<br />
<br />
UAT/staging проблемы не решает: конфигурация, как правило, различается для разных environment, поэтому протестировав сервисы в UAT/staging вы протестируете конфигурацию UAT/staging, но не PROD. <br />
<br />
Проверить конфигурацию методом пристального взгляда (code review) не очень реально: в более-менее крупном проекте объем конфигурации измеряется сотнями и тысячами строк, и мало кто знает смысл и ограничения всех существующих параметров, и как они взаимодействуют с другими параметрами.<br />
<br />
Из всего вышесказанного очевидно: потребность в тестировании конфигурации столь же сильная, что и потребность в тестировании кода. <br />
<br />
<br />
При этом сложного в тестах конфигурации ничего особого нет. Простейшие тесты конфигурации пишутся на коленке за полчаса, как обычные jUnit тесты, запускаются на компьютере разработчика перед коммитом (если у разработчика есть доступ к конфигурации, конечно), вместе с остальными юнит-тестами, и позволяют получать информацию об ошибках сильно быстрее.<br />
<br />
По моему опыту, самый существенный барьер не технический, а психологический. Выглядят-то тесты конфигурации как юнит-тесты, но фактически лазают по файловой системе, какие-то файлики там читают&#8230; Т.е. как юнит-тесты они выглядят странновато и кривовато. Да и вообще сама идея что конфигурацию нужно тестировать так же, как код &#8212; требует времени, чтобы к ней привыкнуть. Но это вопрос привычки: вспомните, сколько времени разработчики привыкали к идее, что нужно тестировать код.<br />
<br />
А еще конфигурация не заканчивается на <code>.properties/.xml</code>: можно тестировать crontabs, sql, shell-scripts &#8212; все то, что важно для работы сервисов, и не проверяется другими способами. Не всегда можно протестировать во всей полноте, но почти всегда можно написать тест, закрывающий путь конкретному классу ошибок, которые больше всего портят жизнь. <br />
<br />
<br />
Мы пишем тесты конфигурации уже года 3 (спасибо Андрею Сатарину, который принес эту идею &#8212; его собственный <a href="http://2017.heisenbug-moscow.ru/talks/2017/msk/79fuksrzakwwqu4cmikw62/">рассказ</a> про тестирование конфигурации был на московском Гейзенбаге 2017). И за 3 года написания и поддержки мы набрели на несколько удачных решений.<br />
<br />
Например, для тестирования взаимозависимостей между параметрами разных сервисов полезно построить модель предметной области &#8212; т.е. модель деплоймента приложения. Формализовать в виде программных объектов environments, сервера, сервисы, конфигурационные файлы, и как это все между собой связано в вашем случае. Тогда тесты будут выглядеть не как &#8220;пойди в ту папочку, возьми такой файлик&#8230;&#8221;, а как &#8220;для каждого environment-а в конфигурации сервиса ХХХ на primary-сервере те же самые порты, что и в конфигурации того же сервиса ХХХ на backup-сервере того же environment-а". Такая модель полезна сама по себе &mdash; в ходе ее создания проясняется много всякого неявного знания о деплойменте. <br />
<br />
А еще для тестирования конфигурацию удобно представлять не как <code>Properties</code>, а как <code>Stream</code> из кортежей типа <code>[environment, server, service, configFile, propertyName, propertyValue]</code>. Тесты в таком виде выглядят более единообразно, кроме того если тест падает, то в сообщении об ошибке автоматом будет весь адрес злокозненного свойства.<br />
<br />
<br />
Ну и на закуску был case-study: тестирование конфигурации как поддержка для рефакторинга конфигурации. Есть сложная и запутанная система конфигурации, доставшаяся в наследство, которую нужно упростить и преобразовать в понятный вид. Как построить достаточно плотную сеть тестов, которая позволит удостоверить, что преобразованная конфигурация по-прежнему корректна?<br />
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2018/05/java-2018.html' rel='bookmark' title='permanent link'><abbr class='published' title='2018-05-20T19:47:00+04:00'>19:47</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2018/05/java-2018.html#comment-form' onclick=''>0
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=3513544856743002049&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5' rel='tag'>тестирование</a>,
<a href='https://dev.cheremin.info/search/label/java' rel='tag'>java</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>3 декабря 2017 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='8778403782317071953'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2017/12/reeentrantreadwritelock.html'>Про ReentrantReadWriteLock</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-8778403782317071953'>
Отличная <a href="http://cs.oswego.edu/pipermail/concurrency-interest/2017-October/016208.html">история</a> с любимой группы рассылки concurrency-interest. <br />
<br />
В библиотеке guava есть класс <a href="https://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Striped.html">Striped</a>, предоставляющий разные виды локов, в разбивке по ключам. Сценарий использования, как я его понимаю, такой: есть данные, естественным образом разбитые по ключам К, и эти данные нужно защитить от конкурентного доступа. При этом конкурентный доступ к данным разных ключей вполне допускается. Если использовать одну общую блокировку, то это похоронит весь параллелизм, а заводить по блокировке на каждый ключ может быть слишком накладным, если ключей много. Striped &mdash; промежуточный вариант: при создании задается, сколько блокировок вы готовы создать, и дальше все ключи отображаются на этот ограниченный список блокировок. Один и тот же ключ всегда отображается на один и тот же лок, поэтому корректность гарантируется. Разные ключи, очевидно, тоже иногда отображаются на один лок, но не очень часто (~1/stripes). (Если вы смотрели код <code>j.u.c.ConcurrentHashMap</code>, то должны понимать, откуда эта идея, и как примерно она реализована)<br />
<br />
Cреди разных вариантов этого <code>Striped</code> есть <code>Striped.lazyWeakReadWriteLock()</code>, где объекты <code>ReentrantReadWriteLock</code> создаются лениво, и удерживаются через слабые ссылки. Вероятно, для сценариев, где потенциально ключей очень много, но в каждый конкретный момент используется лишь небольшое подмножество, и потому какие-то локи периодически простаивают без толку. <br />
<br />
И обнаруживается, что в этом варианте <a href="https://github.com/google/guava/issues/2477">корректность нарушается</a>: довольно легко воспроизвести ситуацию, когда к данным одного и того же ключа, защищенным соответствующим локом из <code>Striped.lazyWeakReadWriteLock()</code>, тем не менее получают одновременный доступ два разных потока. Каждый из этих потоков захватил соответствующую блокировку &mdash; но это оказываются две разных блокировки! <br />
<br />
То, что <code>Striped.lazyWeakReadWriteLock().get(key)</code> может возвращать разные локи для одного и того же ключа &mdash; само по себе не удивительно. Если локи создаются лениво, и держатся через слабые ссылки, то в промежутке между двумя вызовами может прийти GC, прибрать тот лок, который был сначала, а на втором вызове взамен его создастся новый лок. Это не кажется проблемой: ведь если GC смог прибрать лок, значит его никто не использовал, никто ничего им не защищал. Но в тестовом сценарии, в котором воспроизводится ошибка, первый лок все это время используется. Как так?<br />
<br />
Оказывается, что использование объекта <code>ReentrantReadWriteLock.writeLock()</code> и использование объекта <code>ReentrantReadWriteLock</code> &mdash; это две разные вещи. <code>ReentrantReadWriteLock</code>, если посмотреть на его код, выступает лишь фасадом к паре объектов <code>.writeLock()</code> и <code>.readLock()</code>. <code>ReentrantReadWriteLock</code> создает оба этих объекта, связывает их через общий объект <code>Sync</code> (который и реализует внутри себя всю логику блокировки) &mdash; и больше ничего и не делает, кроме как предоставляет к ним доступ. Все взаимодействие между <code>.writeLock()</code> и <code>.readLock()</code> идет в обход <code>ReentrantReadWriteLock</code>, и настолько хорошо в обход, что никто из них даже не нуждается в ссылке на родительский объект. <br />
<br />
В результате получается, что в коде типа такого<br />
<pre class="brush: java">private void readLockedMethod() {
        final Lock readLock = stripedLock.get(key).readLock();
        readLock.lock();
        try {
            //в этот момент со стека есть ссылка только на readLock!
        } finally {
            readLock.unlock();
        }
    }
</pre>внутри блокировки только <code>readLock</code> реально используется, и потому достижим (reachable) со стека. Соответствующий же ему <code>ReentrantReadWriteLock</code> внутри и после блокировки никем не используется, и вполне может быть прибран GC. Что и происходит время от времени. И как только это произойдет, при следующем вызове <code>stripedLock.get(key)</code> из другого потока будет создан уже новый <code>ReentrantReadWriteLock</code>, хотя старая блокировка все еще не отпущена. <br />
<br />
Интересно разобраться, кто именно совершил ошибку. Авторы guava полагали (неявно), что <code>ReentrantReadWriteLock</code> вместе с его дочерними объектами это такой неразрывный блок (агрегат), все элементы которого имеют одинаковое время жизни, и они либо все живые (достижимый), либо так же все мусор. На деле же оказалось, что связи между частями <code>ReentrantReadWriteLock</code> более слабые, и эти части могут функционировать независимо и иметь разное время жизни. Ни то, ни другое не было явно прописано в контракте <code>RRWLock</code>, но предположить сильную связность (агрегацию) было довольно естественно. И так же естественно для разработчиков j.u.c реализовать слабую связность (ассоциацию): ведь слабое связывание это одна из мантр хорошего дизайна. <br />
<br />
Как результат обсуждения, вероятно, в новых версиях джавы связность будет <a href="https://bugs.openjdk.java.net/browse/JDK-8189598">усилена</a>: <code>.writeLock()</code> и <code>.readLock()</code> будут иметь обратную ссылку на родительский <code>ReentrantReadWriteLock</code>. Поведение будет более интуитивным &mdash; ценой большего расхода памяти.
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2017/12/reeentrantreadwritelock.html' rel='bookmark' title='permanent link'><abbr class='published' title='2017-12-03T17:27:00+04:00'>17:27</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2017/12/reeentrantreadwritelock.html#comment-form' onclick=''>2
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=8778403782317071953&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/GC' rel='tag'>GC</a>,
<a href='https://dev.cheremin.info/search/label/threading' rel='tag'>threading</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>23 июня 2017 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='8896580884222959569'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2017/06/shenandoah-jpoint-2017.html'>Shenandoah на JPoint 2017</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-8896580884222959569'>
Запоздалый отклик на рассказ о Shenandoah на JPoint 2017 и последокладные разговоры. Я не буду пересказывать Алексея &mdash; лучше Алексея никто Алексея не перескажет, видео наше все. Здесь мои размышления после, и что мне показалось интересным.<br />
<br />
Интересного в Shenandoah много. Для меня в первую очередь интересно, что Шенандо &mdash; первый GC в джаве, который не основан на гипотезе о поколениях.<br />
<br />
Я начну издалека. Базовый алгоритм для сборки мусора это <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">трассировка ссылок</a>: определяем GC Roots, от них идем по ссылкам, и помечаем достижимые объекты как живые. Но на большой куче трассировка потребует много времени. Если мусор собирать в режиме паузы (Stop The World, SWT), то паузы будут долгими. <br />
<br />
Как сделать паузы короче? Логично разбить работу на изолированные кусочки, и обрабатывать их по одному. Однако определение достижимости объектов разбить на изолированные задачки оказывается не так-то просто: в общем случае нельзя проанализировать достижимость какого-то подмножества объектов без того, чтобы протрассировать все остальные объекты в куче. Почему? Потому что, в общем случае, на любой объект из нашего подмножества потенциально может ссылаться любой другой объект. Априори нет способа ограничить поиск входящих ссылок каким-то подмножеством кучи.<br />
<br />
В общем случае это так, да. Но реальные графы ссылок почти никогда не бывают настолько плотные, чтобы все ссылались на всех. (Хотя бы уже потому, что количество исходящих ссылок из каждого объекта ограничено его размером, и очень мало по сравнению с общим количеством объектов в куче). Кажется вероятным, что реальную кучу все-таки можно разбить на регионы, которые сильно связаны внутри себя, но слабо связаны с другими регионами (связность в смысле входящих ссылок). Когда куча разбита на регионы так, что между собой регионы связаны слабо, то GC сможет быстро собирать такие регионы инкрементально, по одному: чтобы собрать регион Х достаточно просканировать сам регион Х, плюс те регионы, из которых есть ссылки в Х &mdash; а таких регионов немного, потому что связность низкая.<br />
<br />
Остается придумать, как же разбить кучу на такие удобные регионы?<br />
<br />
Один из способов решения этой задачи дают generational GC. Generational GC основаны на паре эмпирических наблюдений: "гипотезах о поколениях". Первая (слабая) гипотеза о поколениях утверждает, что большинство объектов умирает молодыми, вторая (сильная) гипотеза утверждает, что старые объекты редко ссылаются на молодые. <br />
<br />
...Когда я впервые познакомился с generational hypothesis, я был уверен, что первая гипотеза самая важная. Ну, не зря же она &mdash; первая? Вторая гипотеза несколько лет жила в моей памяти в виде "ну там еще какие-то дополнительные условия, но они не критичны". Именно так я несколько лет отвечал на собеседованиях, и никто не придирался. С тех пор у меня осталось убеждение, что большинство разработчиков тоже так и думает :)<br />
<br />
На самом деле, конечно, вторая гипотеза о поколениях поважнее первой. Первая гипотеза говорит нам, что если разделим кучу на регионы хронологически (по времени аллокации), то сборка в "молодых" регионах будет очень эффективна &mdash; бОльшая часть объектов по результатам сборки окажется мертвой. Свойство интересное, но само по себе бесполезно: как именно собрать мусор в молодом регионе, если на любой объект из молодого региона теоретически может ссылаться любой объект из любого другого региона? Не трассировать же всю кучу &mdash; если уж мы трассируем всю кучу, так лучше всю кучу сразу и отмаркировать.<br />
<br />
Сильная гипотеза как раз дает подсказку, как собрать мусор в молодом регионе не трассируя всю остальную кучу. Сильная гипотеза говорит, что ссылок из старых регионов в молодые &mdash; мало. Это то самое утверждение о структуре графа связности регионов, которого не хватает. Если ссылок из старых регионов в молодые мало, то их достаточно отслеживать каким-нибудь грубым но дешевым способом (например: card marking), и при сборке молодого региона останется просмотреть лишь небольшой кусок старых регионов. Так мы получаем знакомую схему NewGen + OldGen<br />
<br />
Что изменилось с приходом G1? G1 претендовал на то, чтобы уменьшить паузы при сборке старого поколения (актуально на больших кучах). Для этого и старое и молодое поколение разбито на регионы одинакового размера, G1 отслеживает ссылки между регионами, так что и в старом, и в молодом поколении возможна инкрементальная сборка. В идеале это позволило бы очищать кучу слой за слоем, как луковицу.<br />
<br />
В идеале такая архитектура позволяла бы вообще отказаться от гипотез о поколениях, и от явного выделения старого и молодого поколений. Зачем использовать <i>априорные предположения</i> о структуре связанности регионов, когда доступны апостериорные данные (ссылки между регионами явно отслеживаются)? <br />
<br />
На практике получилось сложнее, чем ожидали. Как я понимаю, часть проблем была чисто техническая &mdash; G1 внутри устроен гораздо сложнее предыдущих сборщиков. А часть проблем связана с тем, что у такой системы регионов оказалось неожиданно много патологических сценариев. Т.е. есть много сценариев, когда сетка регионов разрезает ссылочный граф неудачным образом, и связность между регионами оказывается высокой. В таком сценарии для сборки одного региона необходимо просмотреть множество других, и время сборки не удается сделать низким.<br />
<br />
Чтобы уменьшить проблему пришлось увеличивать <i>подробность</i> отслеживания ссылок между регионами: не просто "регион А ссылается на регион Б", а из какой конкретно области региона А есть ссылки на объект из Б (RememberedSet). Чтобы отслеживать ссылки с такой подробностью пришлось написать много хитрого кода, который потребяет ресурсы. Подробная информация о ссылках между регионами занимает много места (до 40% кучи в G1 бывает занято этими RememberedSet-ами). Все это в сумме тратит время и нервы разработчиков &mdash; сколько лет уже G1 полируют, и только в 9-ке он, наконец, станет выбором по-умолчанию. <br />
<br />
Где в этой картине Shenandoah? Shenandoah делает практически же самое, что G1 <s>только хорошо</s>: разбивает кучу на регионы, отслеживает ссылки между ними, очищает регионы инкрементально. Разница в том, что Shenandoah очищает мусор не в паузах, а параллельно с приложением. И те сценарии, которые для G1 патологические &mdash; то есть вызывают неприемлемые паузы в работе приложения &mdash; для Shenandoah патологическими уже не являются. Для Shenandoah такие сценарии будут не самыми эффективными по CPU &mdash; да, возможно, но не патологическими, потому что паузы в работе приложения остаются минимальными, а повышенное потребление CPU сейчас как правило не критично. <br />
<br />
Shenandoah заимствует у G1 всю красоту идеи регионального сборщика мусора, но выбрасывает весь геморрой с RememberedSet-ами, заменяя их на старый-добрый card mark. Конечно, заплатить все равно приходится &mdash; в той части, где Shenandoah ухитряется собирать мусор параллельно с работой приложения. Там хватает своих тонкостей и накладных расходов. Но вот региональную часть Шенандо получает практически на сдачу.<br />
<br />
Вот именно этот момент больше всего вертится у меня в голове: можно несколько лет шлифовать техническую реализацию, пытаясь обойти недостатки исходной идеи. А можно взять более удачную ключевую идею &mdash; и просто не встретить бОльшую часть проблем. 
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2017/06/shenandoah-jpoint-2017.html' rel='bookmark' title='permanent link'><abbr class='published' title='2017-06-23T02:06:00+04:00'>2:06</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2017/06/shenandoah-jpoint-2017.html#comment-form' onclick=''>5
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=8896580884222959569&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/GC' rel='tag'>GC</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>10 января 2017 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='4461935548046817492'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2017/01/gc-golang.html'>GC: golang и прочие</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-4461935548046817492'>
За последние полгода у меня накопилось статей про разные общетеоретические аспекты сборки мусора. Не столько про джаву как таковую, сколько про более широкий контекст.<br />
<br />
Последний месяц-два много шума из-за go. Команда разработчиков go рапортует о том, что в версии 1.5 их GC работает со средними паузами в районе <i>сотен микросекунд</i>, и максимальными &lt; 10 миллисекунд ну и типа это "прорывное решение", "сборщик мусора для следующего десятилетия" и другие громкие заявления. В связи с этим хорошая статья Mike Hearn на medium: <a href="https://medium.com/@octskyward/modern-garbage-collection-911ef4f8bd8e">Modern Garbage Collection</a> разбирает ситуацию (пока я писал, ее уже перевели <a href="https://habrahabr.ru/company/mailru/blog/318504/">на хабре</a>). <br />
<br />
Если вкратце, то: сборка мусора &mdash; давняя и сложная задача, никто пока не нашел какого-то универсального решения, подходящего всем и всегда. Каждое реальное решение это выбор конкретного набора компромиссов из большого множества возможных. Майк  навскидку перечисляет <i>полтора десятка</i> возможных свойств сборщика мусора, между которыми приходится выбирать, и очевидно, что количество комбинаций огромно. И если кто-то заявляет о прорывных и выдающихся результатах &mdash; скорее всего, он просто забывает упомянуть, какой ценой эти результаты достигнуты.<br />
<br />
В частности, нынешний "прорывной" сборщик мусора в go &mdash; это concurrent mark-sweep, прямой родственник и аналог OpenJDK-CMS в java. С той только разницей, что нет поколений &mdash; да, да, прямо сейчас в go (1.5) не используется сборка по поколениям (хотя это запланировано), собирается вся куча, как единый кусок. При этом, как и в OpenJDK-CMS, в асинхронном режиме нет compaction &mdash; куча дефрагментируется только в режим stop-the-world. Как результат: нужен довольно большой запас памяти, чтобы противостоять фрагментации (желательно примерно вдвое больше реально используемой), и на обход кучи тратится довольно заметная часть ресурсов CPU.<br />
<br />
CMS в OpenJDK используется для старого поколения, в паре с копирующим сборщиком для молодого поколения. И наибольшие паузы (при правильной настройке), это паузы на сборку молодого поколения. Собирать молодое поколение в асинхронном режиме сложно, потому что сборщик молодого поколения &mdash; перемещающий (чтобы отслеживать асинхронно перемещаемые объекты понадобятся read barrier-ы). Но именно сборка молодого поколения позволяет снизить нагрузку на сам CMS &mdash; лишь небольшая доля объектов доживают до зрелости. Поэтому в джаве CMS (точнее, комбинация CMS + ParNew) в среднем более эффективен с точки зрения накладных расходов: какой избыток памяти нужен, и какую часть CPU time заберет GC. <br />
<br />
В мире realtime java в свое время предлагался <a href="https://pdfs.semanticscholar.org/44b1/1f4ecab634a3283f55929a9c2ed30513ae2d.pdf">Metronome</a> &mdash; сборщик мусора для систем реального времени, для которого можно <i>доказать</i> ограничения на величину вносимых им пауз (правда, паузы там все равно были в районе миллисекунд, но это 2003 год). Платить за это приходилось серьезными затратами CPU: сборка мусора съедала аж <i>50% процессорного времени</i>. В go, вроде бы, все не настолько плохо, но и их GC отъедает <i>десятки процентов</i> CPU в нормальном режиме работы. В джаве нормально настроенный GC обычно ест ~5%<br />
<br />
Gil Tene <a href="https://groups.google.com/d/msg/mechanical-sympathy/JJTUs_jXw5A/55cRmOUoCwAJ">в дискуссии</a> на mechanical sympathy справедливо замечает, что любому техническому решению нужно время, чтобы созреть. Неразумно выносить какие-то окончательные суждения про go GC сейчас, когда весь проект go еще очень молод &mdash; он еще 100 раз успеет мутировать. С его точки зрения, пока что главная опасность в нынешнем сборщике мусора go &mdash; это отсутствие перемещений объектов. Без перемещения объектов сборка мусора неизбежно будет приводить ко фрагментации, и это станет серьезным камнем преткновения по мере развития платформы. Опасность в том, что такое решение может оказаться зафиксированным просто де-факто &mdash; пока это так в нынешней реализации, авторы сторонних библиотек успеют заложиться на фиксированные адреса объектов в памяти, и уже нельзя будет поменять это, не поломав обратной совместимости для большого количества существующего кода. <br />
<br />
Чтобы больше погрузиться в тему компромиссов при сборке мусора: хорошая статья <a href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">A Unified Theory of Garbage Collection</a>. Авторы задались целью показать, как различные подходы к автоматическому управлению памятью на на самом деле представляют собой полюса одного непрерывного спектра решений. И изначально различные реализации по мере обретения зрелости обрастают эвристиками, оптимизациями, становятся все более гибридными, и все меньше отличаются друг от друга. Авторы рассматривают подсчет ссылок (reference counting) и трассировку (tracing) объектов как своего рода взаимо-дополняющие методы управления памятью: где один из них хорош &mdash; другой плох. И любая зрелая реализация трассировки со временем обрастет оптимизациями, представляющими собой, по-сути, ограниченный подсчет ссылок &mdash; и наоборот. Например, card marking, который используется в generational GC чтобы отслеживать ссылки из старого поколения в молодое &mdash; это ни что иное, как вырожденная форма reference counting. Вообще, write barrier-ы &mdash; это прямое указание на какую-то форму подсчета ссылок. <br />
<br />
Другая весьма старая (но не менее интересная) статья Hans Boehm-а на тему компромиссов: <a href="https://www.hboehm.info/gc/complexity.html">Mark-sweep vs. copying collection and asymptotic complexity</a>. Ханс рассматривает Mark-Sweep и копирующий сборщики, и задается вопросом, насколько их общеизвестные теоретические свойства действительно реализуются в реальных условиях. <br />
<br />
Например: считается, что время работы копирующего сборщика пропорционально количеству живых объектов, в то время как для Mark-Sweep это время пропорционально общему объему кучи. Такая оценка Mark-Sweep основана на том, что в sweep-фазе нужно обойти все "мертвые" объекты, чтобы добавить их во free-set. Ханс замечает, что sweep-фаза вообще не является обязательной: можно ставить пометки только на живых объектах, а при аллокации сканировать кучу напропалую, ищя первый кусок памяти без пометки "живой". Этот алгоритм будет эффективен, если значительная (бОльшая) часть кучи после сборки окажется пустой &mdash; но ровно же в этом случае и копирующий сборщик становится эффективным! <br />
<br />
Ханс рассматривает несколько аналогичных "общепринятых" свойств, и показывает, что на практике не всегда все так очевидно, как кажется. 
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2017/01/gc-golang.html' rel='bookmark' title='permanent link'><abbr class='published' title='2017-01-10T02:41:00+04:00'>2:41</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2017/01/gc-golang.html#comment-form' onclick=''>13
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=4461935548046817492&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/GC' rel='tag'>GC</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>4 декабря 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='2565293926192895706'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/12/blog-post.html'>Так что насчет производительности?..</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-2565293926192895706'>
Значительная часть моих историй про скаляризацию состоит из описания того, как все весело разваливается, чуть что-нибудь где-нибудь недозаинлайнилось. После чего у некоторых читателей возникает ощущение "да ну его в жопу, я лучше сам все закэширую, и все гарантированно будет быстро, и не важно, что там как инлайнится". Честно говоря, мне и самому стало интересно, насколько оно все будет быстро, если плохо заинлайнится, поэтому я написал такой несложный бенчмарк:<br />
<pre class="brush:java">public class GCCostBenchmark {


 @Param( { "32", "64", "128", "256", "1024" } )
 public static int SIZE = 128;

 ArrayList&lt;Integer> list = new ArrayList&lt;>();

 @Setup
 public void setup() {
  final ThreadLocalRandom rnd = ThreadLocalRandom.current();
  for( int i = 0; i < SIZE; i++ ) {
   list.add( rnd.nextInt() );
  }
 }


 @Benchmark
 public long sumWithIterator() {
  long sum = 0;
  for( final Integer n : list ) {
   sum += n;
  }
  return sum;
 }

 @Benchmark
 public long sumWithIndex() {
  long sum = 0;
  for( int i = 0; i &lt; list.size(); i++ ) {
   final Integer n = list.get( i );
   sum += n;
  }
  return sum;
 }
}
</pre>
Просто создаем <code>ArrayList</code> разных размеров, заполняем его случайными числами, и в цикле суммируем. И смотрим на два разных варианта организации цикла: через итератор, и старперский, через индекс. 
<pre>Benchmark               (SIZE)   Mode  Cnt   Score    Error   Units
sumWithIndex                32  thrpt    5  27.195 &#177;  3.476  ops/us
sumWithIndex                64  thrpt    5  15.362 &#177;  0.443  ops/us
sumWithIndex               128  thrpt    5   8.359 &#177;  0.775  ops/us
sumWithIndex               256  thrpt    5   4.243 &#177;  0.268  ops/us
sumWithIndex              1024  thrpt    5   1.115 &#177;  0.029  ops/us
sumWithIterator             32  thrpt    5  24.300 &#177;  0.244  ops/us
sumWithIterator             64  thrpt    5  12.973 &#177;  0.056  ops/us
sumWithIterator            128  thrpt    5   7.415 &#177;  0.035  ops/us
sumWithIterator            256  thrpt    5   4.023 &#177;  0.392  ops/us
sumWithIterator           1024  thrpt    5   1.138 &#177;  0.012  ops/us
</pre>Видно, что на моей JDK 1.8.0_102 они идут ноздря в ноздрю: вариант с индексом слегка обходит итератор, но различие в пределах погрешностей. Ок, это будет наша реперная точка. 

Теперь мы запускаем тот же бенчмарк, но с флагом <code>-XX:-EliminateAllocations</code>. В у бенчмарка с итератором, разумеется, появляются строчки gc-profiler-а <code>gc.alloc.rate.norm=32.000&#177;0.001 B/op</code>, но меня интересуют другие цифры:
<pre>Benchmark                (SIZE)   Mode  Cnt    Score    Error   Units
sumWithIndex                 32  thrpt    5   27.063 &#177;  1.527  ops/us
sumWithIndex                 64  thrpt    5   15.571 &#177;  0.243  ops/us
sumWithIndex                128  thrpt    5    7.795 &#177;  0.066  ops/us
sumWithIndex                256  thrpt    5    4.213 &#177;  0.022  ops/us
sumWithIndex               1024  thrpt    5    1.120 &#177;  0.011  ops/us
sumWithIterator              32  thrpt    5   21.022 &#177;  1.452  ops/us
sumWithIterator              64  thrpt    5   11.295 &#177;  2.082  ops/us
sumWithIterator             128  thrpt    5    6.145 &#177;  0.273  ops/us
sumWithIterator             256  thrpt    5    3.359 &#177;  0.035  ops/us
sumWithIterator            1024  thrpt    5    0.905 &#177;  0.032  ops/us
</pre>Как и можно было бы ожидать, итерация с индексом почти никак не отреагировала на этот флаг, а итератор стал медленнее, примерно на ~15-20%. 

Но это я волевым решением отрезал скаляризацию. А давайте сэмулируем отсутствие инлайнинга (и <i>как следствие</i> &mdash; скаляризации): 
<pre>-XX:CompileCommand="dontinline,java.util.AbstractList::*"
-XX:CompileCommand="dontinline,java.util.ArrayList::*"
</pre>&mdash; я отключаю инлайнинг для всех методов <code>ArrayList/AbstractList</code> (ну, чтобы уж с надежностью):
<pre>Benchmark                (SIZE)   Mode  Cnt    Score    Error   Units
sumWithIndex                 32  thrpt    5    2.767 &#177;  0.033  ops/us
sumWithIndex                 64  thrpt    5    1.410 &#177;  0.012  ops/us
sumWithIndex                128  thrpt    5    0.709 &#177;  0.003  ops/us
sumWithIndex                256  thrpt    5    0.357 &#177;  0.003  ops/us
sumWithIndex               1024  thrpt    5    0.093 &#177;  0.003  ops/us
sumWithIterator              32  thrpt    5    3.528 &#177;  0.055  ops/us
sumWithIterator              64  thrpt    5    1.821 &#177;  0.029  ops/us
sumWithIterator             128  thrpt    5    0.933 &#177;  0.015  ops/us
sumWithIterator             256  thrpt    5    0.464 &#177;  0.020  ops/us
sumWithIterator            1024  thrpt    5    0.119 &#177;  0.003  ops/us
</pre>Без инлайнинга производительность цикла просела <b>в 10 раз</b>! (кстати, теперь версия с итератором работает быстрее :)<br />
<br />
Пример немного искусственный: уж больно много разных loop optimizations отваливается без инлайнинга. Для кода более общего вида настолько радикального падения производительности не будет. Но в целом, мораль истории такова: если у вас где-то в горячем коде не сработал инлайнинг &mdash; у вас скорее всего уже достаточно серьезные проблемы с производительностью в этом месте. Не скаляризованные аллокации добавят сюда лишь какие-то крохи. 
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/12/blog-post.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-12-04T22:43:00+04:00'>22:43</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/12/blog-post.html#comment-form' onclick=''>0
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=2565293926192895706&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>,
<a href='https://dev.cheremin.info/search/label/performance' rel='tag'>performance</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>29 ноября 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='854449435625281512'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/11/jug-ekb.html'>Видео с jug-ekb</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-854449435625281512'>
Сентябрьский доклад на jug-ekb. Спасибо организаторам:<br />
<iframe width="480" height="270" src="https://www.youtube.com/embed/QBQoiLxh9lE" frameborder="0" allowFullScreen=""></iframe><br />
<iframe width="480" height="270" src="https://www.youtube.com/embed/WyanmWXuEFU" frameborder="0" allowFullScreen=""></iframe>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/11/jug-ekb.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-11-29T18:40:00+04:00'>18:40</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/11/jug-ekb.html#comment-form' onclick=''>0
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=854449435625281512&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>25 ноября 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='3712498786155616545'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/11/mapget.html'>Скаляризация Map.get(...) -- продолжение</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-3712498786155616545'>
...которое было задумано <a href="http://dev.cheremin.info/2016/10/mapgetnew-compositekeykey1-key2.html">сразу после</a>, но неожиданно задержалось:  сложная политическая обстановка, на работе завал, в Москве пробки, гомеопаты атакуют, а в фейсбуке регулярно кто-то не прав &mdash; как тут найти время?<br />
<br />
После прочтения предыдущего поста возникает <s>депрессия</s>вопрос: можно ли как-то добиться стабильной скаляризации ключей? Краткий ответ: нет. Более полный ответ: нет, стабильной скаляризации в JVM (HotSpot) добиться невозможно. JIT &mdash; это рулетка. Смиритесь. <br />
<br />
... Но побарахтаться все-таки можно. Ни один из способов ниже я не готов считать "хорошим" &mdash; в том смысле, что они не являются примером хорошего кода, и их вряд ли стоит внедрять в свой обычный стиль программирования. Тем не менее, иметь возможность побарахтаться, мне кажется, всегда лучше, чем не иметь :)<br />
<br />
Во-первых, можно просто уменьшить размер метода <code>.equals()</code>. Казалось бы, куда уж меньше:<br />
<pre class="brush:java">public boolean equals( final Object o ) {
 if( this == o ) {
  return true;
 }
 if( !( o instanceof StringKey ) ) {
  return false;
 }

 final StringKey key = ( StringKey ) o;

 return item1.equals( key.item1 )
   && item2.equals( key.item2 );
}
</pre><br />
(Напомню, что этот метод комплируется в 55 байт, что больше 35 &mdash; порога вклеивания для не-горячих методов). Оказывается, однако, что меньше можно:<br />
<pre class="brush:java">public boolean equals( final Object o ) {
 if( this == o ) {
  return true;
 }
 if( !( o instanceof StringKey ) ) {
  return false;
 }

 final StringKey key = ( StringKey ) o;

 return equals( key );
}

private boolean equals( final StringKey key ) {
 return item1.equals( key.item1 )
   && item2.equals( key.item2 );
}
</pre><br />
Первый <code>.equals(Object)</code> комплируется в 27 байт, второй в 34, и тот и другой проходят под порогом. В данном примере такое разбиение имеет самостоятельный смысл: типизированный <code>.equals(StringKey)</code> может быть полезен сам по себе, но вообще-то надо понимать, что мы здесь используем в своих интересах несовершенство эвристики вклеивания &mdash; большие методы нужно декомпозировать чтобы код был читабельным и переиспользуемым, а не чтобы переиграть JIT в очко. <br />
<br />
Не стоит забывать так же, что увеличивая глубину стека вызовов мы увеличиваем вероятность наступить на порог инлайнинга по глубине (<code>MaxInlineLevel=9</code>) &mdash; в изолированном бенчмарке эта вероятность невелика, но в реальной программе она гораздо выше. Кроме того, хотя маленьким методам уже не обязательно быть горячими, но им все равно нужно выполниться хотя бы 250 раз (<code>MinInliningThreshold</code>) чтобы JIT счел их достойными вклеивания.<br />
<br />
Ок, в конце-концов можно взять другую реализацию хэш-таблицы. Я пробовал trove <code>THashMap</code>, и guava <code>ImmutableMap</code>. По моим наблюдениям, в обоих случаях ситуация немного лучше, чем с <code>j.u.HashMap</code>, но именно что немного: да, скаляризация случается чаще, но все равно не всегда. Посмотрим, например, на <code>THashMap</code>:<br />
<pre class="brush:java">public V get(Object key) {
    int index = index(key);
    return index < 0 ? null : _values[index];
}

protected int index(Object obj) {
    if (obj == null)
        return indexForNull();

    // From here on we know obj to be non-null
    final int hash = hash(obj) & 0x7fffffff;
    int index = hash % _set.length;
    Object cur = _set[index];


    if (cur == FREE) {
        return -1;
    }

    if (cur == obj || equals(obj, cur)) {
        return index;
    }

    return indexRehashed(obj, index, hash, cur);
}

private int indexRehashed(Object obj, int index, int hash, Object cur) {
    final Object[] set = _set;
    final int length = set.length;

    // NOTE: here it has to be REMOVED or FULL (some user-given value)
    // see Knuth, p. 529
    int probe = 1 + (hash % (length - 2));

    final int loopIndex = index;

    do {
        index -= probe;
        if (index < 0) {
            index += length;
        }
        cur = set[index];
        //
        if (cur == FREE)
            return -1;

        //
        if ((cur == obj || equals(obj, cur)))
            return index;
    } while (index != loopIndex);

    return -1;
}
</pre>

Я наблюдаю два основных сценария, как здесь обламывается скаляризация: во-первых, какой-то из методов <code>index()/indexRehashed()</code> не вклеивается с диагностикой <code>"already compiled into a big method"</code>. Например, вот так (size=1024, hit probability=2%): 
<pre>  @ 84   ...THashMap::get (21 bytes)   inline (hot)
   \-> TypeProfile (74492/74492 counts) = gnu/trove/map/hash/THashMap
    @ 2   ...TObjectHash::index (72 bytes)   inline (hot)
      @ 11   ...TObjectHash::hash (5 bytes)   inline (hot)
        @ 1   ...$StringKey::hashCode (5 bytes)   accessor
      @ 54   ...TObjectHash::equals (19 bytes)   inline (hot)
        @ 15   ...$StringKey::equals (55 bytes)   inline (hot)
          @ 29   j.l.String::equals (81 bytes)   (intrinsic)
          @ 43   j.l.String::equals (81 bytes)   (intrinsic)
      @ 68   ...TObjectHash::indexRehashed (80 bytes)   already compiled into a big method
</pre>
В <a href="https://youtu.be/K6c3W6vhQOA?list=PLVe-2wcL84b-Waky1nkWVSNHPg6eOQWU9">докладе</a> я разбирал точно такой сценарий на примере <code>LinkedList</code>, напомню вкратце: здесь возникает конфликт между двумя разными эвристиками инлайнинга, и итоговое решение зависит от того, какой из методов скомплируется раньше, а какой позже. А раз порядок компиляции недетерминирован, то и результат тоже: один и тот же код при одинаковых параметрах 5 раз подряд покажет успешную скаляризацию, а на 6-й какой-нибудь посторонний процесс оттянет на себя CPU, слегка изменит соотношение времен исполнения задач компиляции, и все, прощай. 
<p>Второй же сценарий провала скаляризации напоминает <code>j.u.HashMap</code>: поиск в <code>THashMap</code> тоже распадается на две ветки (см. выше), одна для прямого попадания, и вторая для разрешения коллизий (<code>indexRehashed</code>), и если одна из этих веток сильно доминирует, то вторая просто не разогреется достаточно сильно, чтобы JIT решил ее вклеить, а порог инлайнинга для не-горячих методов <code>.indexRehashed()</code> явно превышает (диагностика <code>"too big"</code>).
<p>(guava <code>ImmutableMap</code> я подробно разбирать не буду: стабильной скаляризации нет и там, хотя метод <code>.get()</code> там чуть ли не самый компактный)
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/11/mapget.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-11-25T17:08:00+04:00'>17:08</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/11/mapget.html#comment-form' onclick=''>0
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=3712498786155616545&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>8 октября 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='5089829437803215187'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/10/mapgetnew-compositekeykey1-key2.html'>Скаляризация Map.get(new CompositeKey(key1, key2, ...))</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-5089829437803215187'>
Один из самых интересных примеров из моего последнего доклада на jug-ekb (на JPoint этот пример не влез) это скаляризация композитных ключей в поиске по словарю:<br />
<pre class="brush: java">final Map&lt;CompositeKey, V&gt; map = ...;

...
    final CompositeKey key = new CompositeKey( key1, key2, ... );
    final V value = map.get( key );
...
</pre>Это весьма частый паттерн: нам нужно отображение вида <code>[key1, key2, key3...] -> value</code>. Наиболее простой и очевидный способ это сделать: как раз таки использовать композитный ключ (кортеж из ключей). Решение отличное по всем показателям, кроме одного: для каждого поиска в словаре придется создавать новый объект. <br />
<p>Иногда хочется этого избежать. Тогда приходится организовывать иерархические словари-словарей-словарей... &mdash; я видел много таких примеров (поиск по текущему проекту находит аж 5 различных реализаций чего-то вроде <code>TwoKeyMap/ThreeKeyMap</code>). Это решение мне самому не нравится (хотя 2 из 5 упомянутых реализаций &mdash; мои). Например, словарь-словарей это совсем другой тип, нежели словарь-словарей-словарей &mdash; расширение ключа на одну позицию не является прозрачным, окружающий код специализирован под конкретное число ключей. У этого решения, как правило, хуже производительность: во-первых, потому что приходится делать 2-3-4... поиска вместо одного, а во-вторых потому, что соответствующие словари обычно получаются очень неравномерно заполненными. Скажем, <code>key1</code> может иметь всего 3-4 разных значения, а лежать они будут в таблице размером по-умолчанию (16). При этом, скажем, ключей вида <code>("A", *)</code> всего 2, а вида <code>("B", *)</code> &mdash; 10000. То есть часто образуется много сильно недозаполненных таблиц, вперемешку с несколькими нормальными. Будь все эти ключи в одной таблице &mdash; все эти неоднородности сильно сгладились бы. <br />
<br />
В общем, хотелось бы и чтобы все было хорошо, и за это не приходилось бы ничего платить. Может ли JIT сам скаляризовать аллокацию ключа в сценарии типа <code>map.get( new CompositeKey( key1, key2, ... ) )</code>? <br />
<br />
...Этот сценарий попортил мне немало крови: я несколько раз переписывал код на плюс-минус такой же, и каждый раз получая какие-то новые результаты. Пару раз я готов был включить очередные результаты в презентацию, и только из-за недостатка времени обрезал эту часть, а через недельку обнаруживал, что чуть было не представил неверные результаты. Окончательно (ну, я сейчас так считаю) у меня дошли руки разобраться с ним перед екатеринбургским jug-ом &mdash; времени там было точно достаточно, и уже самому хотелось закрыть эту тему. <br />
<br />
Как выглядит сам бенчмарк: я генерирую пул строк, из них образую парные композитные ключи (<code>StringKey</code>), которыми наполняю хэш-таблицу. Внутри главного цикла бенчмарка я создаю ключи таким образом, чтобы они присутствовали или отсутствовали в словаре с какой-то вероятностью (hit probability &mdash; один из параметров сценария), и запрашиваю у словаря соответствующие значения. <br />
<br />
<pre class="brush:java">private final Pool&lt;String> keys = poolOf( randomUniqueStrings( 2 * SIZE ) );

private final Pool&lt;String> nonExistentKeys = poolOf( randomUniqueStrings( 2 * SIZE ) );

//...

public long run() {
 final boolean successful = ( rnd.nextDouble() <= SUCCESSFUL_LOOKUPS_PROBABILITY );
 
 final String key1;
 final String key2;
 if( successful ) {
  key1 = keys.next();
  key2 = keys.next();
 } else {
  key1 = nonExistentKeys.next();
  key2 = nonExistentKeys.next();
 }

 final String value = map.get( new StringKey( key1, key2 ) );

 if( value == null ) {
  return 0;
 } else {
  return 1;
 }
}
</pre>
<p>Что получается на выходе: иногда ключи скаляризуются почти стабильно, для целого спектра размеров таблицы (1,2,4...65) и спектра hit probability=(0%, 50%, 100%). А иногда &mdash; почти стабильно не скаляризуются. А иногда вообще какая-то ересь получается: сценарий аллоцирует что-то вроде 120 байт на вызов, вместо обычных 24-х &mdash; что уже вообще ни в какие ворота. Поведение меняется от небольших изменений в коде, и от того, использую ли я в качестве ключей свой собственный класс <code>StringKey</code>, или заменяю его на <code>ImmutablePair</code> из apache commons.
<p>Дальше я буду идти от теории к практике &mdash; порассуждаю про код, и подтвержу свои рассуждения примерами. В реальности все происходило ровно наоборот: я сначала поставил много экспериментов, результаты которых были довольно запутывающими, а потом уже построил модель, что и как происходит. Такая история, конечно, гораздо увлекательнее, но пересказывать ее уж очень долго выходит.
<p>Начнем с кода <code>HashMap.get()</code>. В 1.8.0_102 он выглядит так: 
<pre class="brush:java">public V get(Object key) {
        Node&lt;K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    final Node&lt;K,V> getNode(int hash, Object key) {
        Node&lt;K,V>[] tab; Node&lt;K,V> first, e; int n; K k;
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V>)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
</pre>Что мы можем здесь увидеть &mdash; помимо того, что автору неплохо бы пересмотреть свой стиль именования переменных? Мы можем увидеть, что здесь две ветки &mdash; "прямое попадание", и процедура разрешения коллизий, и внутри второй ветки &mdash; еще две ветки (поиск в связном списке или дереве). Чтобы скаляризация имела шанс сработать, нам необходимо (но не достаточно), чтобы заинлайнились <i>все</i> методы, в которые уходит интересующий нас объект (key), до самого низа. В данном случае, как минимум, должны заинлайниться <code>hashCode()</code>, <b>оба</b> вызова <code>.equals()</code> и <code>.getTreeNode()</code>. 
</p>А что нужно, чтобы метод заинлайнился? О, это большая тема :) Инлайнинг &mdash; одна из самых потенциально эффективных оптимизаций в JIT-ах, так что эвристик у нее <a href="https://wiki.openjdk.java.net/display/HotSpot/Server+Compiler+Inlining+Messages">немало</a>. К счастью, все они нам обычно не нужны, достаточно сильно сокращенной версии:
<ol><li>Если метод-кандидат виртуальный &mdash; он должен быть девиртуализован. Для девиртуализации необходимо либо чтобы CHA показал, что сейчас в JVM в принципе загружена только одна реализация, либо чтобы профиль, собранный во время исполнения (TypeProfile) показал, что в данном конкретном месте (вероятно) вызывается не более двух реализаций виртуального метода.</li>
<li>Если метод-кандидат достаточно горячий (горячесть вычисляется как по абсолютному количеству вызовов, так и по тому, насколько часто метод-кандидат вызывается из того метода, в который мы его собираемся вклеивать), то его размер в байт-кодах должен быть не больше <code>FreqInlineSize</code>(=325), и размер в машинных кодах (если он уже был скомпилирован изолированно) не больше <code>SmallInlineSize</code>(=2000).</li>
<li>Если метод недостаточно горячий, то, возможно, он хотя бы маленький (&lt; <code>MaxInlineSize(=35)</code>)? Но, при этом, он должен все-таки выполниться хоть сколько-то: как минимум, <code>MinInliningThreshold(=250)</code> раз. А иначе какой смысл вклеивать?</li>
<li>...Но если какая-то ветка не выполнилась вообще ни разу (за время профилирования), то C2 выкинет ее код вообще, а на случай "а вдруг" поставит вместо нее т.н. <code>uncommon trap</code>: перезапуск выполнения метода в режиме интерпретатора. Эта часть уже не является частью политики инлайнинга, это отдельная, и очень мощная спекулятивная оптимизация, но она очень помогает скаляризации: ведь если весь код ветки выброшен, то он не анализируется на предмет убегания ссылок. </li>
</ol>(Обычному java-программисту непривычно думать о размере метода в байт-кодах, поэтому цифры типа 325 и 35 могут выглядеть довольно абстрактно. Точного соотношения между размером джава-кода и размером байт-кода, разумеется, нет, но по порядку величины можно сказать так: 325 байт это довольно большой метод, примерно на полстраницы-страницу, а 35 байт это коротенький метод, на 3-4 строчки)
<p>...Итак, у нас есть код поиска ключа в хэш-таблице, который состоит из нескольких этапов (веток): поиск нужной корзинки (bucket), сравнение (по хэш-коду и по <code>.equals()</code>), поиск по списку коллизий (по хэш-коду и по <code>.equals()</code>) или поиск по дереву коллизий (там вообще мрак и ужас). И поиск может завершиться на любом этапе, но вся идея хэш-таблицы как структуры данных в том, что <i>как правило</i> у нас списки коллизий короткие, или отсутствуют вовсе. То есть, если раскладка данных в хэш-таблице достаточно равномерная (==хэш-функция хорошая), то вероятность завершить поиск на первом же этапе довольно высока, вероятность попасть в ветку разрешения коллизий &mdash; заметно меньше, а вероятность наткнуться на список коллизий настолько длинный, чтобы он конвертировался в дерево &mdash; совсем маленькая. Более точно, можно выделить такие сценарии:
<ol><li>Попали в пустую корзинку: этот сценарий довольно часто (с вероятностью = 1 - load factor = 25%..60%) будет реализовываться, когда мы будем искать несуществующие в таблице ключи (hit probability << 100%). Здесь вызывается только <code>key.hashCode()</code>, ни один из 2х <code>.equals()</code>, ни <code>.getTreeNode()</code> не вызывается вообще </li>
<li>Попали в корзинку с единственной парой ключ-значение: этих сценариев будет большинство среди тех, когда мы вообще что-то найдем (==ключ присутствует в таблице). В этом случае мы дернем <code>key.hashCode()</code>, и первый <code>.equals()</code>, а второй <code>.equals()</code> и <code>.getTreeNode()</code> все так же не выполняются</li>
<li>Попали в корзинку с несколькими парами ключ-значение, но нашли нужный нам ключ с первой же попытки &mdash; наш маршрут через код совпадает с предыдущим</li>
<li>Наконец, мы попали в корзинку с несколькими парами, и нашли нужный ключ <i>не с первой попытки</i>, либо вообще его не нашли, просмотрев весь список коллизий. В этом случае мы успеем дернуть <code>key.hashCode()</code>, и оба <code>.equals()</code>, (<code>.getTreeNode()</code>все так же не у дел)</li>
<li>Для редкостных неудачников: мы попали в корзинку с >8 парами ключ-значение, при общем размере таблицы >64, и обнаружили, что корзинка сконвертирована в <code>TreeBin</code> &mdash; тут, наконец, мы заглянем во <strike>врата ада</strike><code>.getTreeNode()</code></li>
</ol>Из всего этого уже можно начать рисовать различные сценарии "что может пойти не так с инлайнингом (и, как следствие, скаляризацией)". 
<p>Во-первых, очевидно, у нас могут доминировать сценарии &#8470;1. В этом варианте может оказаться, что ни один из двух <code>.equals()</code> не набрал достаточного количества вызовов, чтобы оказаться горячим, и тогда код <code>.equals()</code> должен быть ну очень коротким, чтобы пролезть под порогом инлайнинга для не горячих методов (35 байт). Например, такой вот, стандартный  
<pre class="brush:java">public boolean equals( final Object o ) {
 if( this == o ) {
  return true;
 }
 if( !( o instanceof StringKey ) ) {
  return false;
 }

 final StringKey key = ( StringKey ) o;

 return item1.equals( key.item1 )
   && item2.equals( key.item2 );
}
</pre>компилируется в 55 байт, и не пролезает. 
<p>Как я уже упоминал, на этот сценарий реальнее всего попасть когда большинство искомых ключей в таблице отсутствуют. В самом деле, запуская сценарий с (HashMap.size=64, hit probability=0%) мы получаем грустную историю дискриминации толстяков:
<pre>@ 84   j.u.HashMap::get (23 bytes)   inline (hot)
 \-> TypeProfile (11045/11045 counts) = java/util/HashMap
  @ 2   j.u.HashMap::hash (20 bytes)   inline (hot)
    @ 9   ...StringKey::hashCode (19 bytes)   inline (hot)
      @ 4     j.l.String::hashCode (55 bytes)   inline (hot)
      @ 14    j.l.String::hashCode (55 bytes)   inline (hot)
  @ 6   j.u.HashMap::getNode (148 bytes)   inline (hot)
    @ 59   ...StringKey::equals (55 bytes)   too big       <--- 
    @ 126  ...StringKey::equals (55 bytes)   too big       <--- 
</pre>   
Видно, что ни один из двух .equals() не вклеился. <code>too big</code> это лишь один из вариантов, я наблюдал так же и <code>executed < MinInliningThreshold</code>
<p>Если мы начнем увеличивать hit probability, то очень быстро "разогреем" первый <code>.equals()</code>: (size=64, hit probability=1%, 2%, ... )
</p><pre>@ 84   j.u.HashMap::get (23 bytes)   inline (hot)
 \-> TypeProfile (11045/11045 counts) = java/util/HashMap
  @ 2   j.u.HashMap::hash (20 bytes)   inline (hot)
    @ 9   ...StringKey::hashCode (19 bytes)   inline (hot)
      @ 4     j.l.String::hashCode (55 bytes)   inline (hot)
      @ 14    j.l.String::hashCode (55 bytes)   inline (hot)
  @ 6   j.u.HashMap::getNode (148 bytes)   inline (hot)
    @ 59   ...StringKey::equals (55 bytes)   inline (hot)    <---
      @ 29     j.l.String::equals (81 bytes)   (intrinsic)
      @ 43     j.l.String::equals (81 bytes)   (intrinsic)
    @ 126  ...StringKey::equals (55 bytes)   too big         <---
</pre>  
Увеличивая hit probability дальше, мы в какой-то момент разогреем и второй <code>.equals()</code>. Точный момент указать сложно, потому что ключи каждый раз генерируются заново, и раскладка по корзинкам получается в каждом запуске немного другая (а она зависит еще и от размера таблицы...), да и сбор профиля внутри JVM &mdash; тоже не детерминированный процесс. Вот сейчас у меня получилось достичь этого при hit probability=5%: 
<pre>...
@ 84   j.u.HashMap::get (23 bytes)   inline (hot)
 \-> TypeProfile (112592/112592 counts) = java/util/HashMap
  @ 2   j.u.HashMap::hash (20 bytes)   inline (hot)
    @ 9   ...StringKey::hashCode (19 bytes)   inline (hot)
      @ 4     j.l.String::hashCode (55 bytes)   inline (hot)
      @ 14    j.l.String::hashCode (55 bytes)   inline (hot)
  @ 6   j.u.HashMap::getNode (148 bytes)   inline (hot)
    @ 59   ...StringKey::equals (55 bytes)   inline (hot)   <---
      @ 29     j.l.String::equals (81 bytes)   (intrinsic)
      @ 43     j.l.String::equals (81 bytes)   (intrinsic)
    @ 126  ...StringKey::equals (55 bytes)   inline (hot)   <---
      @ 29     j.l.String::equals (81 bytes)   (intrinsic)
      @ 43     j.l.String::equals (81 bytes)   (intrinsic)
...
</pre>
И да &mdash; бинго! &mdash; в этом сценарии ключи начали скаляризоваться, код больше ничего не аллоцирует. 
<p>Среди прочего, интересно заметить, что в логе компиляции .getTreeNode() вообще не упоминается. Это все потому, что соответствующая ветка вообще не используется, и JIT заменил ее на <code>uncommon trap</code> &mdash; большая любезность с его стороны, а то у нас были бы околонулевые шансы добиться скаляризации в этом примере хоть когда-нибудь.
<p>До сих пор все просто и логично. Вот только я точно помню, что в каких-то старых вариантах бенчмарка наблюдал стабильную скаляризацию для всего спектра hit probability, в том числе и = 0. Как такое могло происходить? 
<p>Оказывается (это "оказывается" стоило мне нескольких часов недосыпа), я неаккуратно генерировал ключи. В генерации пула "несуществующих" ключей была ошибка, из-за которой с некоторой заметной вероятностью такие ключи все же находились в словаре &mdash; а как мы видели, достаточно небольшой примеси "найденных" ключей, чтобы разогреть холодные ветки. Но этого мало, у меня еще и сами ключи генерировались с очень плохим распределением. Точнее, отдельные-то ключи имели вполне равномерное распределение, но в пары они собирались по порядку, и вот тут-то хэш-код становился буквально кратным 32-м. Это, конечно, создавало очень неравномерное распределение по корзинкам, и длинные списки коллизий, а длинные списки коллизий еще сильнее ускоряли разогрев соответствующей ветки. 
<p>Эти же длинные списки коллизий сыграли при переходе на ключи <code>ImmutablePair</code> из apache commons. С <code>ImmutablePair</code> я наблюдал аллокацию аж 120 байт на вызов, которым, вроде, совсем неоткуда там было взяться. А все дело в том, что, в отличие от простого и дубового <code>StringKey</code>, навороченный <code>ImmutablePair implements Comparable</code>, и при превращении цепочки коллизий в дерево, <code>HashMap</code> это пытается использовать, чтобы сделать дерево более красивым. И вот такой код, где-то внутри .getTreeNode():
<pre class="brush:java">static Class&lt;?> comparableClassFor(Object x) {
    if (x instanceof Comparable) {
        Class&lt;?> c; Type[] ts, as; Type t; ParameterizedType p;
        if ((c = x.getClass()) == String.class) // bypass checks
            return c;
        if ((ts = c.getGenericInterfaces()) != null) {   // <---- 
            for (int i = 0; i < ts.length; ++i) {
                if (((t = ts[i]) instanceof ParameterizedType) &&
                    ((p = (ParameterizedType)t).getRawType() ==
                     Comparable.class) &&
                    (as = p.getActualTypeArguments()) != null &&
                    as.length == 1 && as[0] == c) // type arg is c
                    return c;
            }
        }
    }
    return null;
}
</pre>
что он делает? Дело в том, что даже если <code>key1 instanceof Comparable && key2 instanceof Comparable</code>, нельзя так просто взять, и вызвать <code>key1.compareTo(key2)</code>. Нельзя потому, что, возможно, эти <code>Comparable</code> промеж собой не совместимы: может, один из них <code>Comparable&lt;A></code>, а другой <code>Comparable&lt;B></code>. Процитированный код как раз пытается понять, чем конкретно параметризован этот <code>Comparable</code>. И вот вызов <code>c.getGenericInterfaces()</code> как раз и порождает загадочные 120 байт
<p><p>Что получается в итоге? Получается, что успех или неуспех скаляризации зависит от раскладки ключей в хэш-таблице. Интересно что: чем ближе раскладка к идеальной (с точки зрения производительности) "один ключ на одну корзину", тем более вероятно, что ветка разрешения коллизий окажется холодной, и скаляризация не произойдет. Более того, профилирование происходит в начале исполнения кода, и после окончательной компиляции (C2) без веских причин перепрофилирования не будет, а это значит, что версия, скомпилированная по "неудачному" профилю, собранному в начале исполнения, так и будет исполняться дальше, уже независимо от актуального профиля. 

<p>P.S. Первопричина многих подобных нестабильностей в том, эвристики инлайнинга жестко заточены на производительность: мы стараемся вклеивать те методы, от вклеивания которых ожидается наибольший прирост скорости исполнения, и не рвемся вклеивать те, от которых заметного прироста не ожидаем. Это не совсем то, что нужно для скаляризации: скаляризация-то срабатывает по принципу "все или ничего": <i>все</i> маршруты конкретного объекта должны быть доступны для анализа, и если хотя бы один, пусть и редкий, маршрут уходит за горизонт (в невклеенный метод), то скаляризации не сможет работать. С точки зрения производительности же вклеивать редкий метод нет смысла: прирост производительности минимальный, а код раздувается. Скаляризация выступает тут бедным родственником, который вынужден довольствоваться тем, что дают: иначе было бы логично явно учитывать и ее интересы в эвристиках инлайнинга (такой EA-guided inlining предлагался, кажется, еще в Choi99). 
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/10/mapgetnew-compositekeykey1-key2.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-10-08T23:51:00+04:00'>23:51</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/10/mapgetnew-compositekeykey1-key2.html#comment-form' onclick=''>20
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=5089829437803215187&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/%D0%BD%D0%B5%D1%82%20%D0%BF%D0%BE%D0%BA%D0%BE%D1%8F%20%D0%B5%D0%B1%D0%B0%D0%BD%D1%83%D1%82%D1%8B%D0%BC' rel='tag'>нет покоя ебанутым</a>,
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>12 августа 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='130196159053859746'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/08/enumset-scalarization.html'>EnumSet scalarization</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-130196159053859746'>
В эфире очередной выпуск блогопередачи "скаляризуй меня полностью". На этот раз под мою горячую руку попался <code>EnumSet</code>. Первое, что мне про него было интересно &mdash; это, конечно, скаляризация итератора. Ну, потому что по любой коллекции очень удобно ходить циклом foreach, но не всегда хочется за это удобство платить, пусть даже и не дорого: <br />
<pre class="brush: java">public static enum Enum3 {
 FIRST,
 SECOND,
 THIRD
}

...

final EnumSet set = EnumSet.allOf( Enum3.class );

...

//benchmark start
long sum = 0;
for( final Enum e : set ) {
   sum += e.ordinal();
}
return sum;
//benchmark end
</pre>... JIT меня здесь не подвел: как и в большинстве коллекций, которые я до сих пор исследовал, итератор успешно скаляризуется. По-крайней мере, пока количество элементов в перечислении не превышает 64-х. Я не сумел сходу понять, что там такого в <code>JumboEnumSet.EnumSetIterator</code>-е, что смущает скаляризацию, а копать глубже мне немного лениво, потому что ДА ГОСПОДИ ИИСУСЕ КТО Ж ДЕЛАЕТ ПЕРЕЧИСЛЕНИЯ ПО 64+ ЭЛЕМЕНТОВ? Да таких случаев один на 1000, хрен с ней тогда, со скаляризацией, тут о вечном думать пора... <br />
<br />
А вот более практичный вопрос: скаляризуется ли сам <code>EnumSet</code> в примере выше? То есть: если внести создание <code>EnumSet.allOf(...)</code> в бенчмарк &mdash; сумеет ли JIT спроецировать этот <code>EnumSet</code> в простой скалярный <code>long</code>? <br />
<br />
Простой тест показывает, что нет. Но, конечно, гораздо интереснее понять &mdash; почему. По первости я грешил на вот этот метод:<br />
<pre class="brush: java">public static &lt;E extends Enum&lt;E>> EnumSet&lt;E> noneOf(Class&lt;E> elementType) {
   Enum[] universe = getUniverse(elementType);
   if (universe == null)
      throw new ClassCastException(elementType + " not an enum");

   if (universe.length <= 64)
      return new RegularEnumSet<>(elementType, universe);
   else
      return new JumboEnumSet<>(elementType, universe);
}
</pre>мне казалось довольно логичным, что статически предсказать ветку <code>RegularEnumSet/JumboEnumSet</code> невозможно, и получается уже известный сценарий с merge points. Чтобы это проверить я скопировал весь исходный код <code>EnumSet/RegularEnumSet/JumboEnumSet</code> из <code>java.util</code> к себе, и закомментировал ветку с <code>JumboEnumSet</code>. На удивление, это не помогло, и я пошел копать дальше. После какого-то количества промежуточных экспериментов (я уже, было, начал писать свой собственный <code>SimpleEnumSet</code> &mdash; чтобы, начав с крайне простого кода, потом добавлять понемногу функционал, пока скаляризация не сломается) поиск сошелся вот на чем: <code>RegularEnumSet.EnumSetIterator</code> это не-статический внутренний класс. В этом, казалось бы, нет ничего плохого &mdash; если только вы не слушали мой доклад на JPoint, где я уже разбирал ровно такой же случай, только на примере <code>Arrays.asList(..)</code> <br />
<br />
...Оказывается, из-за <a href="https://bugs.openjdk.java.net/browse/JDK-8155769">загадочного бага</a> в JIT-е, скаляризация ломается (не всегда, но часто), если на потенциально скаляризуемый объект ссылается уже скаляризованный объект. То есть <code>EnumSetIterator</code> успешно скаляризуется, но одно из его полей &mdash; неявная ссылка на объект родительского класса, на <code>RegularEnumSet</code> &mdash; застревает костью в горле у алгоритма скаляризации, когда этот алгоритм пытается скаляризовать сам <code>RegularEnumSet</code>. Другими словами, вот такой код<br />
<pre class="brush: java">...
final EnumSet&lt;Enum3> set = EnumSet.allOf( Enum3.class );
final boolean b = set.contains( Enum3.SECOND );
...
</pre>(без итератора) вполне успешно скаляризуется. Как и код с итератором (но без аллокации <code>EnumSet</code>) в самом начале статьи. Проблемы возникают когда мы эти два куска объединяем: когда мы хотим, чтобы одновременно и итератор, и сам <code>RegularEnumSet</code> скаляризовались. Тут нас ждет облом.<br />
<br />
К сожалению, ситуация с <code>EnumSet</code> несколько хуже, чем с <code>Arrays.asList()</code>. В последнем случае итератор был не-статическим классом просто по недосмотру &mdash; раньше это никого не волновало. Сделать его не статическим ничего особо не стоило, никакой функциональности это не мешало. Благодаря <a href="http://hg.openjdk.java.net/jdk9/dev/jdk/rev/531822c47693">усилиям Тагира Валеева</a> это изменение даже было принято патчем в OpenJDK, так что в 9-ке, вероятно, <code>Arrays.asList()</code> будет скаляризоваться без проблем. А вот с <code>EnumSet</code> такое простое решение не пройдет, итератор здесь не-статический не случайно: доступ к родительскому объекту ему необходим для реализации метода <code>remove()</code>. Остается надеяться только на то, что <a href="https://bugs.openjdk.java.net/browse/JDK-8155769">JDK-8155769</a> когда-нибудь починят. <br />
<br />
P.S. Удивительный факт, который остался немного за кадром: в этом коде<br />
<pre class="brush: java">public static &lt;E extends Enum&lt;E>> EnumSet&lt;E> noneOf(Class&lt;E> elementType) {
   Enum[] universe = getUniverse(elementType);
   if (universe == null)
      throw new ClassCastException(elementType + " not an enum");

   if (universe.length <= 64)
      return new RegularEnumSet<>(elementType, universe);
   else
      return new JumboEnumSet<>(elementType, universe);
}
</pre>JIT ухитряется как-то протащить реальный класс перечисления через getUniverse(..), и статически вычислить условие <code>(universe.length <= 64)</code>! Да они там совсем укурились в своем hotspot-dev!<br />
<br />
<br />
P.P.S. Что меня в теме скаляризации вдохновляет сейчас: когда я начинал ее смотреть, я был готов к сценарию, что тут кромешный адъ и тьма египетская, и без знания наизусть всех кишок компилятора разобраться, или предсказать, или починить скаляризацию невозможно. А оказалось, что странности есть, но пока что все они умещаются в очень небольшой список шаблонов. То есть достаточно помнить по пальцам считанное число граблей (пусть даже не про все из них понятно, откуда они взялись), да знать ключики типа <code>-XX:+PrintCompilation/-XX:+PrintInlining</code>, и в большинстве случаев скаляризацию удается заставить работать, либо обозначить ключевые причины, почему она в таком коде работать и не будет. Пока, по крайней мере, все выглядит так. 
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/08/enumset-scalarization.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-08-12T01:28:00+04:00'>1:28</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/08/enumset-scalarization.html#comment-form' onclick=''>12
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=130196159053859746&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>30 июня 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='4661125704875407300'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/06/tricky-scalar-replacement.html'>Tricky scalar replacement: больше-меньше </a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-4661125704875407300'>
В <a href="http://dev.cheremin.info/2016/02/tricky-scalar-replacement.html">предыдущей серии</a> я уже писал, что такой код:<br />
<pre class="brush: java">private double allocateConditionally( final ThreadLocalRandom rnd ) {
 final Vector2D v;
 if( rnd.nextBoolean() ) {
  v = new Vector2D( 1, rnd.nextDouble() );
 } else {
  v = new Vector2D( rnd.nextDouble(), 1 );
 }

 return v.length();
}</pre>не скаляризуется &mdash; хотя интуитивно кажется, что скаляризация здесь должна быть тривиальной. <br />
<br />
А что если немного <i>добавить</i> аллокаций?<br />
<pre class="brush: java">private double allocateConditionally2( final ThreadLocalRandom rnd ) {
 final Vector2D result = new Vector2D();

 if( rnd.nextBoolean() ) {
  final Vector2D v = new Vector2D( 1, rnd.nextDouble() );
  result.copyFrom(v);
 } else {
  final Vector2D v = new Vector2D( rnd.nextDouble(), 1 );
  result.copyFrom(v);
 }

 return result.length();
}</pre>В этом коде на одну точку аллокации больше &mdash; но все эти аллокации успешно скаляризуются. В общем-то, ничего особо удивительного: здесь каждая ссылочная переменная в любых сценариях исполнения всегда адресует один-единственный объект, поэтому никаких сложностей у скаляризации не возникает :) 
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/06/tricky-scalar-replacement.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-06-30T18:21:00+04:00'>18:21</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/06/tricky-scalar-replacement.html#comment-form' onclick=''>2
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=4661125704875407300&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>21 июня 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='1836020921476845273'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/06/escape-analysis-scalarization-jpoint.html'>Escape Analysis & Scalarization  (видео с jpoint)</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-1836020921476845273'>
Наконец-то выложили финальное обработанные записи докладов с JPoint. Среди прочих и мой доклад про Escape Analysis и скаляризацию. Кажется, получилось неплохо :) <br />
<br />
<iframe width="560" height="315" src="https://www.youtube.com/embed/K6c3W6vhQOA?list=PLVe-2wcL84b-Waky1nkWVSNHPg6eOQWU9" frameborder="0" allowfullscreen></iframe>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/06/escape-analysis-scalarization-jpoint.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-06-21T23:49:00+04:00'>23:49</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/06/escape-analysis-scalarization-jpoint.html#comment-form' onclick=''>0
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=1836020921476845273&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>,
<a href='https://dev.cheremin.info/search/label/JVM%20internals' rel='tag'>JVM internals</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

          </div></div>
        

          <div class="date-outer">
        
<h2 class='date-header'><span>25 марта 2016 г.</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='5758749733861221655'></a>
<h3 class='post-title entry-title'>
<a href='https://dev.cheremin.info/2016/03/blog-post.html'>А почему бы не аллоцировать на стеке?</a>
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-5758749733861221655'>
В самом деле: почему? Вот мы прогнали escape analysis на коде метода, обнаружили, что такие-то создаваемые объекты за пределы метода не утекают. Зачем мы их скаляризуем, почему бы нам просто не аллоцировать их на стеке? Ведь скаляризация, на первый взгляд, сложнее аллокации на стеке: отследить, какие операции с полями объектов к именно какому объекту в этот момент относятся, завести под эти поля локальные переменные, преобразовать код, чтобы он обращался к этим переменным, а не к полям объекта, приготовить задел для деоптимизации... Зачем нам весь этот геморрой, когда можно просто выделить кусок памяти на стеке, и впечатать туда объект? И мы получим полноценную ссылку на него, ничем не отличающуюся от ссылки на объект в куче. Ссылку, которую можно запихнуть в любую дырку, куда пролезет обычная ссылка (ну, слишком-то глубоко мы ее не запихаем &mdash; мы же знаем, что за пределы метода она не уйдет). <br />
<br />
Насколько я понимаю, одного простого ответа на это "почему" нет. Более того, существовали прототипы стековой аллокации &mdash; в одной из статей по EA авторы упоминают, что их прототип делал по результатам EA именно стековую аллокацию (правда, тот прототип был на базе IBM JVM). <br />
<br />
Но стековая аллокация не так уж проста, когда речь заходит о деталях: JVM (Oracle/Open JDK) знает, сколько памяти выделено ей под кучу &mdash; эта информация задается при запуске, и не может быть изменена. И VM этим пользуется: сразу же при старте резервирует у ОС диапазон адресов размером с максимальную кучу (не аллоцирует память, а просто резервирует адреса <code>HEAP_START..HEAP_END = -Xmx</code> реальная же аллокация происходит по необходимости). И с самого первого момента жизни у JVM есть эти два числа <code>[HEAP_START..HEAP_END]</code>, между которыми должно лежать значение любого указателя на java-объект, и JVM активно полагается на то, что куча это непрерывный кусок памяти <code>[HEAP_START..HEAP_END]</code>. Например, эти числа можно вклеивать в генерируемый код прямо в виде констант. <br />
<br />
Или, например, card marking. Я уже как-то писал о нем в контексте concurrency: generational GC должен как-то отслеживать ссылки между объектами разных поколений. Чтобы собрать молодое поколение, нужно знать, какие ссылки на него существуют в полях объектов старого поколения (они становятся частью root set-а). Разумеется, сканировать старое поколение целиком значит похоронить всю идею generational GC, объем сканирования нужно как-то сузить. Для этого JVM разбивает кучу на блоки-"карты" размером 512 байт, и для каждого такого блока держит однобайтовый признак "была ли в пределах этого блока запись ссылки". Каждая запись ссылки обновляет заодно и card marks: очень грубо, строчка <code>a.f = ref</code> из java-кода превращается примерно в <br />
<pre>a.f = ref;
cardMarks[ (addressOf(a.f)-HEAP_START) >> 9 ] = 1
</pre>Т.е. мы записали ссылку в поле какого-то объекта, и пометили блок памяти, содержащий этот объект, как модифицированный. (Это относится только к записям ссылок &mdash; примитивные типы card marks не обновляют, потому что GC до них нет дела). Перед сборкой молодого поколения GC пройдет все модифицированные блоки, соберет из них ссылки, ведущие в молодое поколение, и добавит их в root set.<br />
<br />
Код card marking такой простой потому, что мы заранее знаем начало кучи, какого она размера, и что она непрерывна. Поэтому нам достаточно одного-единственного массива cardMarks, и мы можем уже на старте JVM аллоцировать его нужного размера (<code>= HEAP_SIZE / 512</code>), сразу подо всю, даже еще не аллоцированную, кучу. Очевидно, что если теперь <code>a</code> в коде выше вдруг указывает на объект на стеке, то мы получим выход за границы массива <code>cardMarks</code>, потому что стеки потоков точно никак не попадут в зарезервированный под кучу интервал адресов. Чтобы обрабатывать ссылки на объекты в куче и объекты на стеке одновременно нужно, чтобы код card marking-а был заметно сложнее, скорее всего, содержал какие-то проверки и условные переходы. А это, на минуточку, код записи ссылки &mdash; одна из самых базовых операций, из самых часто исполняемых фрагментов кода. Типичная java-программа ссылками оперирует, пожалуй, чаще, чем примитивными типами! Получается, что немного ускорив аллокацию (точнее, де-аллокацию, сборку мусора &mdash; аллокация из TLAB в яве и так быстрее некуда) за счет использования стека мы одновременно <i>замедлили один из самых горячих фрагментов кода</i> &mdash; запись ссылки. Какой итоговый эффект это окажет на производительность/время отклика приложения в целом &mdash; большой и нетривиальный вопрос. <br />
<br />
Card marking это только один из примеров того, как неожиданно непросто впихнуть стековые объекты в архитектуру JVM, годами заточенную под манипуляции объектами из кучи. Этот пример простой, но, возможно, уже не самый актуальный &mdash; как я понимаю (могу ошибаться), в G1 уже пришлось делить общий массив cardMarks на отдельные массивчики для каждого блока. Возможно, теперь уже не так уж сложно втиснуть в эту схему еще несколько "блоков" для стеков потоков. Но это не единственный такой пример, если судить по переписке в hotspot-dev: <br />
<em><br />
...I tried implementing direct stack allocation in Hotspot a couple of years ago. It was a pain to try to allocate anything outside the heap - there are a lot of checks to make sure that your objects live on the heap. I ended up creating TLAB-like regions in the heap that could hold objects allocated in a stack-like way. It was a lot easier that way, and seemed to give the kinds of performance benefits you would expect. (Jeremy Manson,  01/27/14, <a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2014-January/012319.html">@hotspot-dev</a>)<br />
</em><br />
&mdash; оказывается, что проще создать свой собственный "стек" <s>с гетерами и панкратионом</s>: откусывать от общей кучи пулы памяти на каждый поток, и использовать их для аллокации неубегающих объектов, на манер стека. И <a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2014-February/012384.html">прототип реализации</a> был написан еще два года назад. И где тот стек сейчас?..<br />
<br />
...Я сейчас думаю, что, возможно, дело вообще не в сложности технической реализации аллокации на стеке. Дело в том, что непонятно, так ли уж это нужно. В самом деле, чтобы устранить аллокацию в куче нужно а) чтобы алгоритм EA сумел показать, что объект не утекает за границы текущей единицы компиляции б) чтобы алгоритм скаляризации сумел преобразовать все обращения к этому объекту в обращения к его скаляризованной версии. Переход от скаляризации к аллокации на стеке улучшит пункт "б" (сделает его почти 100%-ным). Сейчас, <a href="http://dev.cheremin.info/2016/02/tricky-scalar-replacement.html">в некоторых случаях</a>, алгоритм скаляризации может спасовать, даже если алгоритм EA и распознал локальность объекта, а с введением аллокации на стеке почти все такие случаи будут обрабатываться. Но вот много ли таких случаев? Точнее: во-первых, в каком проценте случаев скаляризация пасует сейчас, и во-вторых &mdash; какой процент <i>от общего числа аллоцированных в программе объектов</i> мы сможем таким образом выиграть? Я экспериментирую сейчас с различными сценариями, и складывается ощущение, что ответ на первый вопрос может быть довольно заметным &mdash; ну, скажем, сейчас мы скаляризуем 60-70% объектов, распознанных EA как неубегающие, а будем аллоцировать на стеке все 100%. А вот общий эффект для среднестатистической программы может быть скромным, если вообще заметным. <br />
<br />
Вот недавно мне попалась (спасибо твиттеру) свежая <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf">статья</a>, про очередной улучшенный алгоритм EA, в конце каковой статьи приведены результаты применения улучшенного алгоритма к разным бенчмаркам из наборов <a href="http://dacapobench.org/">DeCapo</a> и <a href="https://www.spec.org/jbb2005/">SPECjbb2005</a>. Результат: в среднем устранено примерно ~15% аллокаций в куче. Это довольно продвинутый алгоритм EA, в паре со "стековой" аллокацией &mdash; то есть, приблизительно и ориентировочно, можно взять эти 15% аллокаций за оценку сверху возможностей используемого сейчас алгоритма EA. И переход от используемой сейчас скаляризации к какому-нибудь варианту "стековой" аллокации позволит выиграть какую-нибудь треть от этих 15%. <br />
<br />
Каким бы совершенным не был "скаляризатор", его поле деятельности ограничено теми не-убегающими аллокациями, которые ему скормит EA. Алгоритм EA в java почти не менялся со времен 1.6. Да и чисто теоретически: возможности EA отыскать не-убегающие аллокации, в свою очередь, тоже ограничены: в пределах одного метода, даже с учетом агрессивного инлайнинга, особо не развернешься, а межпроцедурную оптимизацию JIT сейчас не выполняет. Увеличивать агрессивность инлайнинга? &mdash; Неплохой вариант, в основном потому, что дает пинок, наряду со скаляризацией, сразу целому ряду других оптимизаций. И действительно, в 1.8 многие ограничения на инлайнинг ослаблены, и я вижу, как некоторые сценарии, не скаляризовавшиеся в 1.7, в 1.8 начали скаляризоваться. Но особо далеко по этому пути тоже не пройдешь: чрезмерный инлайнинг раздувает код, и с какого-то момента это начинает уже ухудшать производительность. Получается, что существенный прирост можно получить только совершенствуя сразу и скаляризацию, и алгоритм EA, и, по-возможности, увеличивая размер единицы оптимизации, либо подключая межпроцедурную оптимизацию.<br />
<br />
В таком рассуждении есть нюанс: когда мы пытаемся оценить профит от улучшений, прогоняя их на существующих уже программах, мы незаметно попадаем в ловушку. Существующие программы написаны с использованием существующих практик написания кода, и в этих практиках &mdash; и вообще в опыте разработчиков &mdash; уже учтены характерные особенности языка и платформы. Опытные разработчики, сознательно или бессознательно, уже оптимизируют свой код под известные сильные и слабые стороны платформы. Говоря проще: если бы было общеизвестно, что в java есть великолепный EA и скаляризатор, и что редкий временный объект имеет шанс быть аллоцированным в куче &mdash; многие программы были бы написаны сильно иначе, чем они написаны сейчас, когда общеизвестно, что да, GC довольно неплохо управляется с короткоживущими объектами, а некоторые объекты даже и скаляризуются, но не всегда, и не все, и вообще как фишка ляжет. В упомянутой выше статье, наряду с набором java-бенчмарков, был взят аналогичный набор Scala-бенчмарков (ScalaDeCapo). И разница очень заметна: (Java)DeCapo от включения EA получает бонус в -5% аллокаций, а ScalaDeCapo &mdash; в -15%. Общий прирост производительности (Java)DeCapo: +2.2%, ScalaDeCapo: +9%. В Scala другие наборы best practices, другой компилятор, другая стандартная библиотека...
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Кто:
<span class='fn'>Ruslan Cheremin</span>
</span>
<span class='post-timestamp'>
в
<a class='timestamp-link' href='https://dev.cheremin.info/2016/03/blog-post.html' rel='bookmark' title='permanent link'><abbr class='published' title='2016-03-25T19:57:00+04:00'>19:57</abbr></a>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='https://dev.cheremin.info/2016/03/blog-post.html#comment-form' onclick=''>53
откликов</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1114183539'>
<a href='https://www.blogger.com/post-edit.g?blogID=410416665291724878&postID=5758749733861221655&from=pencil' title='Изменить сообщение'>
<img alt='' class='icon-action' height='18' src='https://resources.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
<span class='post-backlinks post-comment-link'>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Ярлыки:
<a href='https://dev.cheremin.info/search/label/escape%20analysis' rel='tag'>escape analysis</a>,
<a href='https://dev.cheremin.info/search/label/GC' rel='tag'>GC</a>,
<a href='https://dev.cheremin.info/search/label/JVM%20internals' rel='tag'>JVM internals</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'><span class='post-location'>
</span>
</div>
</div>
</div>
</div>

        </div></div>
      
</div>
<div class='blog-pager' id='blog-pager'>
<span id='blog-pager-older-link'>
<a class='blog-pager-older-link' href='https://dev.cheremin.info/search?updated-max=2016-03-25T19:57:00%2B04:00&max-results=20' id='Blog1_blog-pager-older-link' title='Предыдущие'>Предыдущие</a>
</span>
<a class='home-link' href='https://dev.cheremin.info/'>Главная страница</a>
</div>
<div class='clear'></div>
<div class='blog-feeds'>
<div class='feed-links'>
Подписаться на:
<a class='feed-link' href='https://dev.cheremin.info/feeds/posts/default' target='_blank' type='application/atom+xml'>Сообщения (Atom)</a>
</div>
</div>
<script type='text/javascript'>
    window.___gcfg = { 'lang': 'ru' };
  </script>
</div></div>
</div>
</div>
<div class='column-left-outer'>
<div class='column-left-inner'>
<aside>
</aside>
</div>
</div>
<div class='column-right-outer'>
<div class='column-right-inner'>
<aside>
<div class='sidebar section' id='sidebar-right-1'><div class='widget Image' data-version='1' id='Image1'>
<div class='widget-content'>
<a href="//www.blogger.com/profile/01023948540752159657">
<img alt='' height='200' id='Image1_img' src='//3.bp.blogspot.com/-AiDAHaDnVJA/ToNbOKdhOBI/AAAAAAAADBg/DCvMs1OkSiU/s300/%25D0%25AF2.jpg' width='300'/>
</a>
<br/>
</div>
<div class='clear'></div>
<span class='widget-item-control'>
<span class='item-control blog-admin'>
<a class='quickedit' href='//www.blogger.com/rearrange?blogID=410416665291724878&widgetType=Image&widgetId=Image1&action=editWidget&sectionId=sidebar-right-1' onclick='return _WidgetManager._PopupConfig(document.getElementById("Image1"));' target='configImage1' title='Изменить'>
<img alt='' height='18' src='https://resources.blogblog.com/img/icon18_wrench_allbkg.png' width='18'/>
</a>
</span>
</span>
<div class='clear'></div>
</div><div class='widget Label' data-version='1' id='Label1'>
<h2>Тэги</h2>
<div class='widget-content cloud-label-widget-content'>
<span class='label-size label-size-5'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/threading'>threading</a>
<span class='label-count' dir='ltr'>(54)</span>
</span>
<span class='label-size label-size-5'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/performance'>performance</a>
<span class='label-count' dir='ltr'>(48)</span>
</span>
<span class='label-size label-size-4'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B5%D0%B5'>рабочее</a>
<span class='label-count' dir='ltr'>(29)</span>
</span>
<span class='label-size label-size-4'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/benchmarking'>benchmarking</a>
<span class='label-count' dir='ltr'>(21)</span>
</span>
<span class='label-size label-size-4'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/jmm'>jmm</a>
<span class='label-count' dir='ltr'>(21)</span>
</span>
<span class='label-size label-size-4'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/JVM%20internals'>JVM internals</a>
<span class='label-count' dir='ltr'>(17)</span>
</span>
<span class='label-size label-size-4'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/disruptor'>disruptor</a>
<span class='label-count' dir='ltr'>(15)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D0%BD%D0%B5%D1%82%20%D0%BF%D0%BE%D0%BA%D0%BE%D1%8F%20%D0%B5%D0%B1%D0%B0%D0%BD%D1%83%D1%82%D1%8B%D0%BC'>нет покоя ебанутым</a>
<span class='label-count' dir='ltr'>(11)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/escape%20analysis'>escape analysis</a>
<span class='label-count' dir='ltr'>(10)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/non-blocking'>non-blocking</a>
<span class='label-count' dir='ltr'>(9)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85'>структуры данных</a>
<span class='label-count' dir='ltr'>(8)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/GC'>GC</a>
<span class='label-count' dir='ltr'>(7)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D1%84%D0%B8%D0%B7%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80'>физконструктор</a>
<span class='label-count' dir='ltr'>(6)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/azul'>azul</a>
<span class='label-count' dir='ltr'>(5)</span>
</span>
<span class='label-size label-size-3'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/false%20sharing'>false sharing</a>
<span class='label-count' dir='ltr'>(5)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/code%20style'>code style</a>
<span class='label-count' dir='ltr'>(4)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/floating%20point'>floating point</a>
<span class='label-count' dir='ltr'>(4)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/cache-coherency'>cache-coherency</a>
<span class='label-count' dir='ltr'>(3)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/highly%20scalable%20java'>highly scalable java</a>
<span class='label-count' dir='ltr'>(3)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'>тестирование</a>
<span class='label-count' dir='ltr'>(3)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/fork%2Fjoin'>fork/join</a>
<span class='label-count' dir='ltr'>(2)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/java'>java</a>
<span class='label-count' dir='ltr'>(2)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/networking'>networking</a>
<span class='label-count' dir='ltr'>(2)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/reflection'>reflection</a>
<span class='label-count' dir='ltr'>(2)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0'>архитектура</a>
<span class='label-count' dir='ltr'>(2)</span>
</span>
<span class='label-size label-size-2'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%20%D0%BA%D0%BE%D1%80%D0%BE%D0%BB%D0%B5%D0%B2%D0%B0%20%D0%BD%D0%B0%D1%83%D0%BA'>математика королева наук</a>
<span class='label-count' dir='ltr'>(2)</span>
</span>
<span class='label-size label-size-1'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/io'>io</a>
<span class='label-count' dir='ltr'>(1)</span>
</span>
<span class='label-size label-size-1'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/nio'>nio</a>
<span class='label-count' dir='ltr'>(1)</span>
</span>
<span class='label-size label-size-1'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/swing'>swing</a>
<span class='label-count' dir='ltr'>(1)</span>
</span>
<span class='label-size label-size-1'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B'>алгоритмы</a>
<span class='label-count' dir='ltr'>(1)</span>
</span>
<span class='label-size label-size-1'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D0%BC%D0%B0%D1%82%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80'>матконструктор</a>
<span class='label-count' dir='ltr'>(1)</span>
</span>
<span class='label-size label-size-1'>
<a dir='ltr' href='https://dev.cheremin.info/search/label/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'>программирование</a>
<span class='label-count' dir='ltr'>(1)</span>
</span>
<div class='clear'></div>
<span class='widget-item-control'>
<span class='item-control blog-admin'>
<a class='quickedit' href='//www.blogger.com/rearrange?blogID=410416665291724878&widgetType=Label&widgetId=Label1&action=editWidget&sectionId=sidebar-right-1' onclick='return _WidgetManager._PopupConfig(document.getElementById("Label1"));' target='configLabel1' title='Изменить'>
<img alt='' height='18' src='https://resources.blogblog.com/img/icon18_wrench_allbkg.png' width='18'/>
</a>
</span>
</span>
<div class='clear'></div>
</div>
</div><div class='widget BlogArchive' data-version='1' id='BlogArchive1'>
<h2>Архив блога</h2>
<div class='widget-content'>
<div id='ArchiveList'>
<div id='BlogArchive1_ArchiveList'>
<ul class='hierarchy'>
<li class='archivedate expanded'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy toggle-open'>

        &#9660;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2018/'>
2018
</a>
<span class='post-count' dir='ltr'>(4)</span>
<ul class='hierarchy'>
<li class='archivedate expanded'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy toggle-open'>

        &#9660;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2018/08/'>
августа
</a>
<span class='post-count' dir='ltr'>(1)</span>
<ul class='posts'>
<li><a href='https://dev.cheremin.info/2018/08/blog-post.html'>Оценки квантилей распределений потока данных</a></li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2018/07/'>
июля
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2018/06/'>
июня
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2018/05/'>
мая
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2017/'>
2017
</a>
<span class='post-count' dir='ltr'>(3)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2017/12/'>
декабря
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2017/06/'>
июня
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2017/01/'>
января
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/'>
2016
</a>
<span class='post-count' dir='ltr'>(11)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/12/'>
декабря
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/11/'>
ноября
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/10/'>
октября
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/08/'>
августа
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/06/'>
июня
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/03/'>
марта
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2016/02/'>
февраля
</a>
<span class='post-count' dir='ltr'>(3)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2015/'>
2015
</a>
<span class='post-count' dir='ltr'>(3)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2015/09/'>
сентября
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2015/08/'>
августа
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2014/'>
2014
</a>
<span class='post-count' dir='ltr'>(2)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2014/03/'>
марта
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2014/02/'>
февраля
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2013/'>
2013
</a>
<span class='post-count' dir='ltr'>(8)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2013/07/'>
июля
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2013/02/'>
февраля
</a>
<span class='post-count' dir='ltr'>(5)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2013/01/'>
января
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/'>
2012
</a>
<span class='post-count' dir='ltr'>(31)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/11/'>
ноября
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/10/'>
октября
</a>
<span class='post-count' dir='ltr'>(4)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/09/'>
сентября
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/08/'>
августа
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/07/'>
июля
</a>
<span class='post-count' dir='ltr'>(3)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/06/'>
июня
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/05/'>
мая
</a>
<span class='post-count' dir='ltr'>(4)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/04/'>
апреля
</a>
<span class='post-count' dir='ltr'>(6)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/03/'>
марта
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/02/'>
февраля
</a>
<span class='post-count' dir='ltr'>(3)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2012/01/'>
января
</a>
<span class='post-count' dir='ltr'>(4)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/'>
2011
</a>
<span class='post-count' dir='ltr'>(46)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/12/'>
декабря
</a>
<span class='post-count' dir='ltr'>(5)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/11/'>
ноября
</a>
<span class='post-count' dir='ltr'>(7)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/10/'>
октября
</a>
<span class='post-count' dir='ltr'>(4)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/09/'>
сентября
</a>
<span class='post-count' dir='ltr'>(5)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/08/'>
августа
</a>
<span class='post-count' dir='ltr'>(4)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/07/'>
июля
</a>
<span class='post-count' dir='ltr'>(5)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/06/'>
июня
</a>
<span class='post-count' dir='ltr'>(6)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/05/'>
мая
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/04/'>
апреля
</a>
<span class='post-count' dir='ltr'>(6)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/03/'>
марта
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2011/02/'>
февраля
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/'>
2010
</a>
<span class='post-count' dir='ltr'>(40)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/12/'>
декабря
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/10/'>
октября
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/09/'>
сентября
</a>
<span class='post-count' dir='ltr'>(4)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/08/'>
августа
</a>
<span class='post-count' dir='ltr'>(5)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/07/'>
июля
</a>
<span class='post-count' dir='ltr'>(6)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/06/'>
июня
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/04/'>
апреля
</a>
<span class='post-count' dir='ltr'>(5)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/03/'>
марта
</a>
<span class='post-count' dir='ltr'>(11)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2010/02/'>
февраля
</a>
<span class='post-count' dir='ltr'>(6)</span>
</li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/'>
2009
</a>
<span class='post-count' dir='ltr'>(14)</span>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/12/'>
декабря
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/11/'>
ноября
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/10/'>
октября
</a>
<span class='post-count' dir='ltr'>(2)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/09/'>
сентября
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/08/'>
августа
</a>
<span class='post-count' dir='ltr'>(4)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/07/'>
июля
</a>
<span class='post-count' dir='ltr'>(3)</span>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

        &#9658;&#160;
      
</span>
</a>
<a class='post-count-link' href='https://dev.cheremin.info/2009/04/'>
апреля
</a>
<span class='post-count' dir='ltr'>(1)</span>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class='clear'></div>
<span class='widget-item-control'>
<span class='item-control blog-admin'>
<a class='quickedit' href='//www.blogger.com/rearrange?blogID=410416665291724878&widgetType=BlogArchive&widgetId=BlogArchive1&action=editWidget&sectionId=sidebar-right-1' onclick='return _WidgetManager._PopupConfig(document.getElementById("BlogArchive1"));' target='configBlogArchive1' title='Изменить'>
<img alt='' height='18' src='https://resources.blogblog.com/img/icon18_wrench_allbkg.png' width='18'/>
</a>
</span>
</span>
<div class='clear'></div>
</div>
</div></div>
</aside>
</div>
</div>
</div>
<div style='clear: both'></div>
<!-- columns -->
</div>
<!-- main -->
</div>
</div>
<div class='main-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<footer>
<div class='footer-outer'>
<div class='footer-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left footer-fauxborder-left'>
<div class='fauxborder-right footer-fauxborder-right'></div>
<div class='region-inner footer-inner'>
<div class='foot no-items section' id='footer-1'></div>
<!-- outside of the include in order to lock Attribution widget -->
<div class='foot section' id='footer-3'><div class='widget Attribution' data-version='1' id='Attribution1'>
<div class='widget-content' style='text-align: center;'>
(&#169;)Черемин Руслан. Технологии <a href='https://www.blogger.com' target='_blank'>Blogger</a>.
</div>
<div class='clear'></div>
<span class='widget-item-control'>
<span class='item-control blog-admin'>
<a class='quickedit' href='//www.blogger.com/rearrange?blogID=410416665291724878&widgetType=Attribution&widgetId=Attribution1&action=editWidget&sectionId=footer-3' onclick='return _WidgetManager._PopupConfig(document.getElementById("Attribution1"));' target='configAttribution1' title='Изменить'>
<img alt='' height='18' src='https://resources.blogblog.com/img/icon18_wrench_allbkg.png' width='18'/>
</a>
</span>
</span>
<div class='clear'></div>
</div></div>
</div>
</div>
<div class='footer-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</footer>
<!-- content -->
</div>
</div>
<div class='content-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<script type='text/javascript'>
    window.setTimeout(function() {
        document.body.className = document.body.className.replace('loading', '');
      }, 10);
  </script>

<script type="text/javascript" src="https://www.blogger.com/static/v1/widgets/1859629982-widgets.js"></script>
<script type='text/javascript'>
window['__wavt'] = 'AOuZoY6wrAfsBNOeNUbdbbwpd_f6IgGkCQ:1538340305499';_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d410416665291724878','//dev.cheremin.info/','410416665291724878');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '410416665291724878', 'title': '\x26gt;рабочие заметки', 'url': 'https://dev.cheremin.info/', 'canonicalUrl': 'https://dev.cheremin.info/', 'homepageUrl': 'https://dev.cheremin.info/', 'searchUrl': 'https://dev.cheremin.info/search', 'canonicalHomepageUrl': 'https://dev.cheremin.info/', 'blogspotFaviconUrl': 'https://dev.cheremin.info/favicon.ico', 'bloggerUrl': 'https://www.blogger.com', 'hasCustomDomain': true, 'httpsEnabled': true, 'enabledCommentProfileImages': true, 'gPlusViewType': 'FILTERED_POSTMOD', 'adultContent': false, 'analyticsAccountNumber': '', 'encoding': 'UTF-8', 'locale': 'ru', 'localeUnderscoreDelimited': 'ru', 'languageDirection': 'ltr', 'isPrivate': false, 'isMobile': false, 'isMobileRequest': false, 'mobileClass': '', 'isPrivateBlog': false, 'feedLinks': '\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22\x26gt;рабочие заметки - Atom\x22 href\x3d\x22https://dev.cheremin.info/feeds/posts/default\x22 /\x3e\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/rss+xml\x22 title\x3d\x22\x26gt;рабочие заметки - RSS\x22 href\x3d\x22https://dev.cheremin.info/feeds/posts/default?alt\x3drss\x22 /\x3e\n\x3clink rel\x3d\x22service.post\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22\x26gt;рабочие заметки - Atom\x22 href\x3d\x22https://www.blogger.com/feeds/410416665291724878/posts/default\x22 /\x3e\n', 'meTag': '', 'adsenseHostId': 'ca-host-pub-1556223355139109', 'adsenseHasAds': false, 'ieCssRetrofitLinks': '\x3c!--[if IE]\x3e\x3cscript type\x3d\x22text/javascript\x22 src\x3d\x22https://www.blogger.com/static/v1/jsbin/3762807459-ieretrofit.js\x22\x3e\x3c/script\x3e\n\x3c![endif]--\x3e', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/3b4dbd5bc7a45d5b', 'plusOneApiSrc': 'https://apis.google.com/js/plusone.js', 'sharing': {'platforms': [{'name': 'Получить ссылку', 'key': 'link', 'shareMessage': 'Получить ссылку', 'target': ''}, {'name': 'Facebook', 'key': 'facebook', 'shareMessage': 'Поделиться в Facebook', 'target': 'facebook'}, {'name': 'Написать об этом в блоге', 'key': 'blogThis', 'shareMessage': 'Написать об этом в блоге', 'target': 'blog'}, {'name': 'Twitter', 'key': 'twitter', 'shareMessage': 'Поделиться в Twitter', 'target': 'twitter'}, {'name': 'Pinterest', 'key': 'pinterest', 'shareMessage': 'Поделиться в Pinterest', 'target': 'pinterest'}, {'name': 'Google+', 'key': 'googlePlus', 'shareMessage': 'Поделиться в Google+', 'target': 'googleplus'}, {'name': 'Электронная почта', 'key': 'email', 'shareMessage': 'Электронная почта', 'target': 'email'}], 'googlePlusShareButtonWidth': 300, 'googlePlusBootstrap': '\x3cscript type\x3d\x22text/javascript\x22\x3ewindow.___gcfg \x3d {\x27lang\x27: \x27ru\x27};\x3c/script\x3e'}, 'hasCustomJumpLinkMessage': false, 'jumpLinkMessage': 'Далее...', 'pageType': 'index', 'pageName': '', 'pageTitle': '\x26gt;рабочие заметки'}}, {'name': 'features', 'data': {'cmt_anon_warn': 'false', 'sharing_get_link_dialog': 'true', 'sharing_native': 'false'}}, {'name': 'messages', 'data': {'edit': 'Изменить', 'linkCopiedToClipboard': 'Ссылка скопирована в буфер обмена!', 'ok': 'ОК', 'postLink': 'Ссылка на сообщение'}}, {'name': 'template', 'data': {'name': 'custom', 'localizedName': 'Дополнительно', 'isResponsive': false, 'isAlternateRendering': false, 'isCustom': true}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\x3dclassic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\x3dflipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\x3dmagazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\x3dmosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\x3dsidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\x3dsnapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\x3dtimeslide'}, 'isMobile': false, 'title': '\x3eрабочие заметки', 'description': 'Рабочие заметки java-программиста. Производительность, concurrency, прочие извращения', 'url': 'https://dev.cheremin.info/', 'type': 'feed', 'isSingleItem': false, 'isMultipleItems': true, 'isError': false, 'isPage': false, 'isPost': false, 'isHomepage': true, 'isArchive': false, 'isLabelSearch': false}}]);
_WidgetManager._RegisterWidget('_NavbarView', new _WidgetInfo('Navbar1', 'navbar', null, document.getElementById('Navbar1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'header', null, document.getElementById('Header1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', null, document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'useNgc': false, 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/3248888496-lbx__ru.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/368954415-lightbox_bundle.css'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_ImageView', new _WidgetInfo('Image1', 'sidebar-right-1', null, document.getElementById('Image1'), {'resize': false}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_LabelView', new _WidgetInfo('Label1', 'sidebar-right-1', null, document.getElementById('Label1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogArchiveView', new _WidgetInfo('BlogArchive1', 'sidebar-right-1', null, document.getElementById('BlogArchive1'), {'languageDirection': 'ltr', 'loadingMessage': 'Загрузка\x26hellip;'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AttributionView', new _WidgetInfo('Attribution1', 'footer-3', null, document.getElementById('Attribution1'), {}, 'displayModeFull'));
</script>
</body>
<!-- -->
<script type='text/javascript'>
     SyntaxHighlighter.config.bloggerMode = true;
     SyntaxHighlighter.defaults.gutter = false;
     SyntaxHighlighter.all()
</script>
</html>